// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `aesm-proto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub initQuoteReq: ::protobuf::SingularPtrField<Request_InitQuoteRequest>,
    pub getQuoteReq: ::protobuf::SingularPtrField<Request_GetQuoteRequest>,
    pub getLicTokenReq: ::protobuf::SingularPtrField<Request_GetLaunchTokenRequest>,
    pub reportErrReq: ::protobuf::SingularPtrField<Request_ReportAttestationErrorRequest>,
    pub getWhiteListSizeReq: ::protobuf::SingularPtrField<Request_GetWhiteListSizeRequest>,
    pub getWhiteListReq: ::protobuf::SingularPtrField<Request_GetWhiteListRequest>,
    pub sgxGetExtendedEpidGroupIdReq: ::protobuf::SingularPtrField<Request_SGXGetExtendedEpidGroupIdRequest>,
    pub sgxSwitchExtendedEpidGroupReq: ::protobuf::SingularPtrField<Request_SGXSwitchExtendedEpidGroupRequest>,
    pub sgxRegisterReq: ::protobuf::SingularPtrField<Request_SGXRegisterRequest>,
    pub initQuoteExReq: ::protobuf::SingularPtrField<Request_InitQuoteExRequest>,
    pub getQuoteSizeExReq: ::protobuf::SingularPtrField<Request_GetQuoteSizeExRequest>,
    pub getQuoteExReq: ::protobuf::SingularPtrField<Request_GetQuoteExRequest>,
    pub checkUpdateStatusReq: ::protobuf::SingularPtrField<Request_CheckUpdateStatusRequest>,
    pub selectAttKeyIDReq: ::protobuf::SingularPtrField<Request_SelectAttKeyIDRequest>,
    pub getSupportedAttKeyIDNumReq: ::protobuf::SingularPtrField<Request_GetSupportedAttKeyIDNumRequest>,
    pub getSupportedAttKeyIDsReq: ::protobuf::SingularPtrField<Request_GetSupportedAttKeyIDsRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;


    pub fn get_initQuoteReq(&self) -> &Request_InitQuoteRequest {
        self.initQuoteReq.as_ref().unwrap_or_else(|| <Request_InitQuoteRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteReq(&mut self) {
        self.initQuoteReq.clear();
    }

    pub fn has_initQuoteReq(&self) -> bool {
        self.initQuoteReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteReq(&mut self, v: Request_InitQuoteRequest) {
        self.initQuoteReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteReq(&mut self) -> &mut Request_InitQuoteRequest {
        if self.initQuoteReq.is_none() {
            self.initQuoteReq.set_default();
        }
        self.initQuoteReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteReq(&mut self) -> Request_InitQuoteRequest {
        self.initQuoteReq.take().unwrap_or_else(|| Request_InitQuoteRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;


    pub fn get_getQuoteReq(&self) -> &Request_GetQuoteRequest {
        self.getQuoteReq.as_ref().unwrap_or_else(|| <Request_GetQuoteRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteReq(&mut self) {
        self.getQuoteReq.clear();
    }

    pub fn has_getQuoteReq(&self) -> bool {
        self.getQuoteReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteReq(&mut self, v: Request_GetQuoteRequest) {
        self.getQuoteReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteReq(&mut self) -> &mut Request_GetQuoteRequest {
        if self.getQuoteReq.is_none() {
            self.getQuoteReq.set_default();
        }
        self.getQuoteReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteReq(&mut self) -> Request_GetQuoteRequest {
        self.getQuoteReq.take().unwrap_or_else(|| Request_GetQuoteRequest::new())
    }

    // optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;


    pub fn get_getLicTokenReq(&self) -> &Request_GetLaunchTokenRequest {
        self.getLicTokenReq.as_ref().unwrap_or_else(|| <Request_GetLaunchTokenRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLicTokenReq(&mut self) {
        self.getLicTokenReq.clear();
    }

    pub fn has_getLicTokenReq(&self) -> bool {
        self.getLicTokenReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLicTokenReq(&mut self, v: Request_GetLaunchTokenRequest) {
        self.getLicTokenReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLicTokenReq(&mut self) -> &mut Request_GetLaunchTokenRequest {
        if self.getLicTokenReq.is_none() {
            self.getLicTokenReq.set_default();
        }
        self.getLicTokenReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLicTokenReq(&mut self) -> Request_GetLaunchTokenRequest {
        self.getLicTokenReq.take().unwrap_or_else(|| Request_GetLaunchTokenRequest::new())
    }

    // optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;


    pub fn get_reportErrReq(&self) -> &Request_ReportAttestationErrorRequest {
        self.reportErrReq.as_ref().unwrap_or_else(|| <Request_ReportAttestationErrorRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reportErrReq(&mut self) {
        self.reportErrReq.clear();
    }

    pub fn has_reportErrReq(&self) -> bool {
        self.reportErrReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportErrReq(&mut self, v: Request_ReportAttestationErrorRequest) {
        self.reportErrReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportErrReq(&mut self) -> &mut Request_ReportAttestationErrorRequest {
        if self.reportErrReq.is_none() {
            self.reportErrReq.set_default();
        }
        self.reportErrReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportErrReq(&mut self) -> Request_ReportAttestationErrorRequest {
        self.reportErrReq.take().unwrap_or_else(|| Request_ReportAttestationErrorRequest::new())
    }

    // optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;


    pub fn get_getWhiteListSizeReq(&self) -> &Request_GetWhiteListSizeRequest {
        self.getWhiteListSizeReq.as_ref().unwrap_or_else(|| <Request_GetWhiteListSizeRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListSizeReq(&mut self) {
        self.getWhiteListSizeReq.clear();
    }

    pub fn has_getWhiteListSizeReq(&self) -> bool {
        self.getWhiteListSizeReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListSizeReq(&mut self, v: Request_GetWhiteListSizeRequest) {
        self.getWhiteListSizeReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListSizeReq(&mut self) -> &mut Request_GetWhiteListSizeRequest {
        if self.getWhiteListSizeReq.is_none() {
            self.getWhiteListSizeReq.set_default();
        }
        self.getWhiteListSizeReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListSizeReq(&mut self) -> Request_GetWhiteListSizeRequest {
        self.getWhiteListSizeReq.take().unwrap_or_else(|| Request_GetWhiteListSizeRequest::new())
    }

    // optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;


    pub fn get_getWhiteListReq(&self) -> &Request_GetWhiteListRequest {
        self.getWhiteListReq.as_ref().unwrap_or_else(|| <Request_GetWhiteListRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListReq(&mut self) {
        self.getWhiteListReq.clear();
    }

    pub fn has_getWhiteListReq(&self) -> bool {
        self.getWhiteListReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListReq(&mut self, v: Request_GetWhiteListRequest) {
        self.getWhiteListReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListReq(&mut self) -> &mut Request_GetWhiteListRequest {
        if self.getWhiteListReq.is_none() {
            self.getWhiteListReq.set_default();
        }
        self.getWhiteListReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListReq(&mut self) -> Request_GetWhiteListRequest {
        self.getWhiteListReq.take().unwrap_or_else(|| Request_GetWhiteListRequest::new())
    }

    // optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;


    pub fn get_sgxGetExtendedEpidGroupIdReq(&self) -> &Request_SGXGetExtendedEpidGroupIdRequest {
        self.sgxGetExtendedEpidGroupIdReq.as_ref().unwrap_or_else(|| <Request_SGXGetExtendedEpidGroupIdRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxGetExtendedEpidGroupIdReq(&mut self) {
        self.sgxGetExtendedEpidGroupIdReq.clear();
    }

    pub fn has_sgxGetExtendedEpidGroupIdReq(&self) -> bool {
        self.sgxGetExtendedEpidGroupIdReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxGetExtendedEpidGroupIdReq(&mut self, v: Request_SGXGetExtendedEpidGroupIdRequest) {
        self.sgxGetExtendedEpidGroupIdReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxGetExtendedEpidGroupIdReq(&mut self) -> &mut Request_SGXGetExtendedEpidGroupIdRequest {
        if self.sgxGetExtendedEpidGroupIdReq.is_none() {
            self.sgxGetExtendedEpidGroupIdReq.set_default();
        }
        self.sgxGetExtendedEpidGroupIdReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxGetExtendedEpidGroupIdReq(&mut self) -> Request_SGXGetExtendedEpidGroupIdRequest {
        self.sgxGetExtendedEpidGroupIdReq.take().unwrap_or_else(|| Request_SGXGetExtendedEpidGroupIdRequest::new())
    }

    // optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;


    pub fn get_sgxSwitchExtendedEpidGroupReq(&self) -> &Request_SGXSwitchExtendedEpidGroupRequest {
        self.sgxSwitchExtendedEpidGroupReq.as_ref().unwrap_or_else(|| <Request_SGXSwitchExtendedEpidGroupRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxSwitchExtendedEpidGroupReq(&mut self) {
        self.sgxSwitchExtendedEpidGroupReq.clear();
    }

    pub fn has_sgxSwitchExtendedEpidGroupReq(&self) -> bool {
        self.sgxSwitchExtendedEpidGroupReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxSwitchExtendedEpidGroupReq(&mut self, v: Request_SGXSwitchExtendedEpidGroupRequest) {
        self.sgxSwitchExtendedEpidGroupReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxSwitchExtendedEpidGroupReq(&mut self) -> &mut Request_SGXSwitchExtendedEpidGroupRequest {
        if self.sgxSwitchExtendedEpidGroupReq.is_none() {
            self.sgxSwitchExtendedEpidGroupReq.set_default();
        }
        self.sgxSwitchExtendedEpidGroupReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxSwitchExtendedEpidGroupReq(&mut self) -> Request_SGXSwitchExtendedEpidGroupRequest {
        self.sgxSwitchExtendedEpidGroupReq.take().unwrap_or_else(|| Request_SGXSwitchExtendedEpidGroupRequest::new())
    }

    // optional .aesm.message.Request.SGXRegisterRequest sgxRegisterReq = 14;


    pub fn get_sgxRegisterReq(&self) -> &Request_SGXRegisterRequest {
        self.sgxRegisterReq.as_ref().unwrap_or_else(|| <Request_SGXRegisterRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxRegisterReq(&mut self) {
        self.sgxRegisterReq.clear();
    }

    pub fn has_sgxRegisterReq(&self) -> bool {
        self.sgxRegisterReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxRegisterReq(&mut self, v: Request_SGXRegisterRequest) {
        self.sgxRegisterReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxRegisterReq(&mut self) -> &mut Request_SGXRegisterRequest {
        if self.sgxRegisterReq.is_none() {
            self.sgxRegisterReq.set_default();
        }
        self.sgxRegisterReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxRegisterReq(&mut self) -> Request_SGXRegisterRequest {
        self.sgxRegisterReq.take().unwrap_or_else(|| Request_SGXRegisterRequest::new())
    }

    // optional .aesm.message.Request.InitQuoteExRequest initQuoteExReq = 15;


    pub fn get_initQuoteExReq(&self) -> &Request_InitQuoteExRequest {
        self.initQuoteExReq.as_ref().unwrap_or_else(|| <Request_InitQuoteExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteExReq(&mut self) {
        self.initQuoteExReq.clear();
    }

    pub fn has_initQuoteExReq(&self) -> bool {
        self.initQuoteExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteExReq(&mut self, v: Request_InitQuoteExRequest) {
        self.initQuoteExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteExReq(&mut self) -> &mut Request_InitQuoteExRequest {
        if self.initQuoteExReq.is_none() {
            self.initQuoteExReq.set_default();
        }
        self.initQuoteExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteExReq(&mut self) -> Request_InitQuoteExRequest {
        self.initQuoteExReq.take().unwrap_or_else(|| Request_InitQuoteExRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteSizeExRequest getQuoteSizeExReq = 16;


    pub fn get_getQuoteSizeExReq(&self) -> &Request_GetQuoteSizeExRequest {
        self.getQuoteSizeExReq.as_ref().unwrap_or_else(|| <Request_GetQuoteSizeExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteSizeExReq(&mut self) {
        self.getQuoteSizeExReq.clear();
    }

    pub fn has_getQuoteSizeExReq(&self) -> bool {
        self.getQuoteSizeExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteSizeExReq(&mut self, v: Request_GetQuoteSizeExRequest) {
        self.getQuoteSizeExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteSizeExReq(&mut self) -> &mut Request_GetQuoteSizeExRequest {
        if self.getQuoteSizeExReq.is_none() {
            self.getQuoteSizeExReq.set_default();
        }
        self.getQuoteSizeExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteSizeExReq(&mut self) -> Request_GetQuoteSizeExRequest {
        self.getQuoteSizeExReq.take().unwrap_or_else(|| Request_GetQuoteSizeExRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteExRequest getQuoteExReq = 17;


    pub fn get_getQuoteExReq(&self) -> &Request_GetQuoteExRequest {
        self.getQuoteExReq.as_ref().unwrap_or_else(|| <Request_GetQuoteExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteExReq(&mut self) {
        self.getQuoteExReq.clear();
    }

    pub fn has_getQuoteExReq(&self) -> bool {
        self.getQuoteExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteExReq(&mut self, v: Request_GetQuoteExRequest) {
        self.getQuoteExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteExReq(&mut self) -> &mut Request_GetQuoteExRequest {
        if self.getQuoteExReq.is_none() {
            self.getQuoteExReq.set_default();
        }
        self.getQuoteExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteExReq(&mut self) -> Request_GetQuoteExRequest {
        self.getQuoteExReq.take().unwrap_or_else(|| Request_GetQuoteExRequest::new())
    }

    // optional .aesm.message.Request.CheckUpdateStatusRequest checkUpdateStatusReq = 18;


    pub fn get_checkUpdateStatusReq(&self) -> &Request_CheckUpdateStatusRequest {
        self.checkUpdateStatusReq.as_ref().unwrap_or_else(|| <Request_CheckUpdateStatusRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checkUpdateStatusReq(&mut self) {
        self.checkUpdateStatusReq.clear();
    }

    pub fn has_checkUpdateStatusReq(&self) -> bool {
        self.checkUpdateStatusReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkUpdateStatusReq(&mut self, v: Request_CheckUpdateStatusRequest) {
        self.checkUpdateStatusReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkUpdateStatusReq(&mut self) -> &mut Request_CheckUpdateStatusRequest {
        if self.checkUpdateStatusReq.is_none() {
            self.checkUpdateStatusReq.set_default();
        }
        self.checkUpdateStatusReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_checkUpdateStatusReq(&mut self) -> Request_CheckUpdateStatusRequest {
        self.checkUpdateStatusReq.take().unwrap_or_else(|| Request_CheckUpdateStatusRequest::new())
    }

    // optional .aesm.message.Request.SelectAttKeyIDRequest selectAttKeyIDReq = 19;


    pub fn get_selectAttKeyIDReq(&self) -> &Request_SelectAttKeyIDRequest {
        self.selectAttKeyIDReq.as_ref().unwrap_or_else(|| <Request_SelectAttKeyIDRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selectAttKeyIDReq(&mut self) {
        self.selectAttKeyIDReq.clear();
    }

    pub fn has_selectAttKeyIDReq(&self) -> bool {
        self.selectAttKeyIDReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectAttKeyIDReq(&mut self, v: Request_SelectAttKeyIDRequest) {
        self.selectAttKeyIDReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectAttKeyIDReq(&mut self) -> &mut Request_SelectAttKeyIDRequest {
        if self.selectAttKeyIDReq.is_none() {
            self.selectAttKeyIDReq.set_default();
        }
        self.selectAttKeyIDReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectAttKeyIDReq(&mut self) -> Request_SelectAttKeyIDRequest {
        self.selectAttKeyIDReq.take().unwrap_or_else(|| Request_SelectAttKeyIDRequest::new())
    }

    // optional .aesm.message.Request.GetSupportedAttKeyIDNumRequest getSupportedAttKeyIDNumReq = 21;


    pub fn get_getSupportedAttKeyIDNumReq(&self) -> &Request_GetSupportedAttKeyIDNumRequest {
        self.getSupportedAttKeyIDNumReq.as_ref().unwrap_or_else(|| <Request_GetSupportedAttKeyIDNumRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSupportedAttKeyIDNumReq(&mut self) {
        self.getSupportedAttKeyIDNumReq.clear();
    }

    pub fn has_getSupportedAttKeyIDNumReq(&self) -> bool {
        self.getSupportedAttKeyIDNumReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSupportedAttKeyIDNumReq(&mut self, v: Request_GetSupportedAttKeyIDNumRequest) {
        self.getSupportedAttKeyIDNumReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSupportedAttKeyIDNumReq(&mut self) -> &mut Request_GetSupportedAttKeyIDNumRequest {
        if self.getSupportedAttKeyIDNumReq.is_none() {
            self.getSupportedAttKeyIDNumReq.set_default();
        }
        self.getSupportedAttKeyIDNumReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSupportedAttKeyIDNumReq(&mut self) -> Request_GetSupportedAttKeyIDNumRequest {
        self.getSupportedAttKeyIDNumReq.take().unwrap_or_else(|| Request_GetSupportedAttKeyIDNumRequest::new())
    }

    // optional .aesm.message.Request.GetSupportedAttKeyIDsRequest getSupportedAttKeyIDsReq = 22;


    pub fn get_getSupportedAttKeyIDsReq(&self) -> &Request_GetSupportedAttKeyIDsRequest {
        self.getSupportedAttKeyIDsReq.as_ref().unwrap_or_else(|| <Request_GetSupportedAttKeyIDsRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSupportedAttKeyIDsReq(&mut self) {
        self.getSupportedAttKeyIDsReq.clear();
    }

    pub fn has_getSupportedAttKeyIDsReq(&self) -> bool {
        self.getSupportedAttKeyIDsReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSupportedAttKeyIDsReq(&mut self, v: Request_GetSupportedAttKeyIDsRequest) {
        self.getSupportedAttKeyIDsReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSupportedAttKeyIDsReq(&mut self) -> &mut Request_GetSupportedAttKeyIDsRequest {
        if self.getSupportedAttKeyIDsReq.is_none() {
            self.getSupportedAttKeyIDsReq.set_default();
        }
        self.getSupportedAttKeyIDsReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSupportedAttKeyIDsReq(&mut self) -> Request_GetSupportedAttKeyIDsRequest {
        self.getSupportedAttKeyIDsReq.take().unwrap_or_else(|| Request_GetSupportedAttKeyIDsRequest::new())
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.initQuoteReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLicTokenReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reportErrReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListSizeReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxGetExtendedEpidGroupIdReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxSwitchExtendedEpidGroupReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxRegisterReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initQuoteExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteSizeExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkUpdateStatusReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selectAttKeyIDReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSupportedAttKeyIDNumReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSupportedAttKeyIDsReq {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteReq)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteReq)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLicTokenReq)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reportErrReq)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListSizeReq)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListReq)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxGetExtendedEpidGroupIdReq)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxSwitchExtendedEpidGroupReq)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxRegisterReq)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteExReq)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteSizeExReq)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteExReq)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkUpdateStatusReq)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selectAttKeyIDReq)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSupportedAttKeyIDNumReq)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSupportedAttKeyIDsReq)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initQuoteReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLicTokenReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reportErrReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListSizeReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxRegisterReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initQuoteExReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteSizeExReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteExReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkUpdateStatusReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selectAttKeyIDReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDNumReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDsReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initQuoteReq.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteReq.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLicTokenReq.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reportErrReq.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListSizeReq.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListReq.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdReq.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupReq.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxRegisterReq.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initQuoteExReq.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteSizeExReq.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteExReq.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkUpdateStatusReq.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selectAttKeyIDReq.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDNumReq.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDsReq.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_InitQuoteRequest>>(
                "initQuoteReq",
                |m: &Request| { &m.initQuoteReq },
                |m: &mut Request| { &mut m.initQuoteReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetQuoteRequest>>(
                "getQuoteReq",
                |m: &Request| { &m.getQuoteReq },
                |m: &mut Request| { &mut m.getQuoteReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetLaunchTokenRequest>>(
                "getLicTokenReq",
                |m: &Request| { &m.getLicTokenReq },
                |m: &mut Request| { &mut m.getLicTokenReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_ReportAttestationErrorRequest>>(
                "reportErrReq",
                |m: &Request| { &m.reportErrReq },
                |m: &mut Request| { &mut m.reportErrReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetWhiteListSizeRequest>>(
                "getWhiteListSizeReq",
                |m: &Request| { &m.getWhiteListSizeReq },
                |m: &mut Request| { &mut m.getWhiteListSizeReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetWhiteListRequest>>(
                "getWhiteListReq",
                |m: &Request| { &m.getWhiteListReq },
                |m: &mut Request| { &mut m.getWhiteListReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_SGXGetExtendedEpidGroupIdRequest>>(
                "sgxGetExtendedEpidGroupIdReq",
                |m: &Request| { &m.sgxGetExtendedEpidGroupIdReq },
                |m: &mut Request| { &mut m.sgxGetExtendedEpidGroupIdReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_SGXSwitchExtendedEpidGroupRequest>>(
                "sgxSwitchExtendedEpidGroupReq",
                |m: &Request| { &m.sgxSwitchExtendedEpidGroupReq },
                |m: &mut Request| { &mut m.sgxSwitchExtendedEpidGroupReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_SGXRegisterRequest>>(
                "sgxRegisterReq",
                |m: &Request| { &m.sgxRegisterReq },
                |m: &mut Request| { &mut m.sgxRegisterReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_InitQuoteExRequest>>(
                "initQuoteExReq",
                |m: &Request| { &m.initQuoteExReq },
                |m: &mut Request| { &mut m.initQuoteExReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetQuoteSizeExRequest>>(
                "getQuoteSizeExReq",
                |m: &Request| { &m.getQuoteSizeExReq },
                |m: &mut Request| { &mut m.getQuoteSizeExReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetQuoteExRequest>>(
                "getQuoteExReq",
                |m: &Request| { &m.getQuoteExReq },
                |m: &mut Request| { &mut m.getQuoteExReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_CheckUpdateStatusRequest>>(
                "checkUpdateStatusReq",
                |m: &Request| { &m.checkUpdateStatusReq },
                |m: &mut Request| { &mut m.checkUpdateStatusReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_SelectAttKeyIDRequest>>(
                "selectAttKeyIDReq",
                |m: &Request| { &m.selectAttKeyIDReq },
                |m: &mut Request| { &mut m.selectAttKeyIDReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetSupportedAttKeyIDNumRequest>>(
                "getSupportedAttKeyIDNumReq",
                |m: &Request| { &m.getSupportedAttKeyIDNumReq },
                |m: &mut Request| { &mut m.getSupportedAttKeyIDNumReq },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request_GetSupportedAttKeyIDsRequest>>(
                "getSupportedAttKeyIDsReq",
                |m: &Request| { &m.getSupportedAttKeyIDsReq },
                |m: &mut Request| { &mut m.getSupportedAttKeyIDsReq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request>(
                "Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request {
        static instance: ::protobuf::rt::LazyV2<Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request::new)
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.initQuoteReq.clear();
        self.getQuoteReq.clear();
        self.getLicTokenReq.clear();
        self.reportErrReq.clear();
        self.getWhiteListSizeReq.clear();
        self.getWhiteListReq.clear();
        self.sgxGetExtendedEpidGroupIdReq.clear();
        self.sgxSwitchExtendedEpidGroupReq.clear();
        self.sgxRegisterReq.clear();
        self.initQuoteExReq.clear();
        self.getQuoteSizeExReq.clear();
        self.getQuoteExReq.clear();
        self.checkUpdateStatusReq.clear();
        self.selectAttKeyIDReq.clear();
        self.getSupportedAttKeyIDNumReq.clear();
        self.getSupportedAttKeyIDsReq.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_InitQuoteRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_InitQuoteRequest {
    fn default() -> &'a Request_InitQuoteRequest {
        <Request_InitQuoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_InitQuoteRequest {
    pub fn new() -> Request_InitQuoteRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_InitQuoteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_InitQuoteRequest {
        Request_InitQuoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_InitQuoteRequest| { &m.timeout },
                |m: &mut Request_InitQuoteRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_InitQuoteRequest>(
                "Request.InitQuoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_InitQuoteRequest {
        static instance: ::protobuf::rt::LazyV2<Request_InitQuoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_InitQuoteRequest::new)
    }
}

impl ::protobuf::Clear for Request_InitQuoteRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_InitQuoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_InitQuoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetQuoteRequest {
    // message fields
    report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    quote_type: ::std::option::Option<u32>,
    spid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sig_rl: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buf_size: ::std::option::Option<u32>,
    qe_report: ::std::option::Option<bool>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteRequest {
    fn default() -> &'a Request_GetQuoteRequest {
        <Request_GetQuoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteRequest {
    pub fn new() -> Request_GetQuoteRequest {
        ::std::default::Default::default()
    }

    // required bytes report = 1;


    pub fn get_report(&self) -> &[u8] {
        match self.report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_report(&mut self) {
        self.report.clear();
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.report.is_none() {
            self.report.set_default();
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::vec::Vec<u8> {
        self.report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 quote_type = 2;


    pub fn get_quote_type(&self) -> u32 {
        self.quote_type.unwrap_or(0)
    }
    pub fn clear_quote_type(&mut self) {
        self.quote_type = ::std::option::Option::None;
    }

    pub fn has_quote_type(&self) -> bool {
        self.quote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_type(&mut self, v: u32) {
        self.quote_type = ::std::option::Option::Some(v);
    }

    // required bytes spid = 3;


    pub fn get_spid(&self) -> &[u8] {
        match self.spid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spid(&mut self) {
        self.spid.clear();
    }

    pub fn has_spid(&self) -> bool {
        self.spid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spid(&mut self, v: ::std::vec::Vec<u8>) {
        self.spid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spid.is_none() {
            self.spid.set_default();
        }
        self.spid.as_mut().unwrap()
    }

    // Take field
    pub fn take_spid(&mut self) -> ::std::vec::Vec<u8> {
        self.spid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes nonce = 4;


    pub fn get_nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sig_rl = 5;


    pub fn get_sig_rl(&self) -> &[u8] {
        match self.sig_rl.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sig_rl(&mut self) {
        self.sig_rl.clear();
    }

    pub fn has_sig_rl(&self) -> bool {
        self.sig_rl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig_rl(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_rl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_rl(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sig_rl.is_none() {
            self.sig_rl.set_default();
        }
        self.sig_rl.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig_rl(&mut self) -> ::std::vec::Vec<u8> {
        self.sig_rl.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 buf_size = 6;


    pub fn get_buf_size(&self) -> u32 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u32) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional bool qe_report = 7;


    pub fn get_qe_report(&self) -> bool {
        self.qe_report.unwrap_or(false)
    }
    pub fn clear_qe_report(&mut self) {
        self.qe_report = ::std::option::Option::None;
    }

    pub fn has_qe_report(&self) -> bool {
        self.qe_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report(&mut self, v: bool) {
        self.qe_report = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteRequest {
    fn is_initialized(&self) -> bool {
        if self.report.is_none() {
            return false;
        }
        if self.quote_type.is_none() {
            return false;
        }
        if self.spid.is_none() {
            return false;
        }
        if self.buf_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.report)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quote_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sig_rl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.qe_report = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.quote_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.spid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.sig_rl.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.qe_report {
            my_size += 2;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.report.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.quote_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.spid.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.sig_rl.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.qe_report {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteRequest {
        Request_GetQuoteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "report",
                |m: &Request_GetQuoteRequest| { &m.report },
                |m: &mut Request_GetQuoteRequest| { &mut m.report },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quote_type",
                |m: &Request_GetQuoteRequest| { &m.quote_type },
                |m: &mut Request_GetQuoteRequest| { &mut m.quote_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spid",
                |m: &Request_GetQuoteRequest| { &m.spid },
                |m: &mut Request_GetQuoteRequest| { &mut m.spid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nonce",
                |m: &Request_GetQuoteRequest| { &m.nonce },
                |m: &mut Request_GetQuoteRequest| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig_rl",
                |m: &Request_GetQuoteRequest| { &m.sig_rl },
                |m: &mut Request_GetQuoteRequest| { &mut m.sig_rl },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buf_size",
                |m: &Request_GetQuoteRequest| { &m.buf_size },
                |m: &mut Request_GetQuoteRequest| { &mut m.buf_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "qe_report",
                |m: &Request_GetQuoteRequest| { &m.qe_report },
                |m: &mut Request_GetQuoteRequest| { &mut m.qe_report },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetQuoteRequest| { &m.timeout },
                |m: &mut Request_GetQuoteRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetQuoteRequest>(
                "Request.GetQuoteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetQuoteRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteRequest {
    fn clear(&mut self) {
        self.report.clear();
        self.quote_type = ::std::option::Option::None;
        self.spid.clear();
        self.nonce.clear();
        self.sig_rl.clear();
        self.buf_size = ::std::option::Option::None;
        self.qe_report = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetQuoteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetLaunchTokenRequest {
    // message fields
    mr_enclave: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mr_signer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    se_attributes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetLaunchTokenRequest {
    fn default() -> &'a Request_GetLaunchTokenRequest {
        <Request_GetLaunchTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetLaunchTokenRequest {
    pub fn new() -> Request_GetLaunchTokenRequest {
        ::std::default::Default::default()
    }

    // required bytes mr_enclave = 1;


    pub fn get_mr_enclave(&self) -> &[u8] {
        match self.mr_enclave.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mr_enclave(&mut self) {
        self.mr_enclave.clear();
    }

    pub fn has_mr_enclave(&self) -> bool {
        self.mr_enclave.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mr_enclave(&mut self, v: ::std::vec::Vec<u8>) {
        self.mr_enclave = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mr_enclave(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mr_enclave.is_none() {
            self.mr_enclave.set_default();
        }
        self.mr_enclave.as_mut().unwrap()
    }

    // Take field
    pub fn take_mr_enclave(&mut self) -> ::std::vec::Vec<u8> {
        self.mr_enclave.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes mr_signer = 2;


    pub fn get_mr_signer(&self) -> &[u8] {
        match self.mr_signer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mr_signer(&mut self) {
        self.mr_signer.clear();
    }

    pub fn has_mr_signer(&self) -> bool {
        self.mr_signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mr_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.mr_signer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mr_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mr_signer.is_none() {
            self.mr_signer.set_default();
        }
        self.mr_signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mr_signer(&mut self) -> ::std::vec::Vec<u8> {
        self.mr_signer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes se_attributes = 3;


    pub fn get_se_attributes(&self) -> &[u8] {
        match self.se_attributes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_se_attributes(&mut self) {
        self.se_attributes.clear();
    }

    pub fn has_se_attributes(&self) -> bool {
        self.se_attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_se_attributes(&mut self, v: ::std::vec::Vec<u8>) {
        self.se_attributes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_se_attributes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.se_attributes.is_none() {
            self.se_attributes.set_default();
        }
        self.se_attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_se_attributes(&mut self) -> ::std::vec::Vec<u8> {
        self.se_attributes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetLaunchTokenRequest {
    fn is_initialized(&self) -> bool {
        if self.mr_enclave.is_none() {
            return false;
        }
        if self.mr_signer.is_none() {
            return false;
        }
        if self.se_attributes.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mr_enclave)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mr_signer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.se_attributes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mr_enclave.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.mr_signer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.se_attributes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mr_enclave.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.mr_signer.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.se_attributes.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetLaunchTokenRequest {
        Request_GetLaunchTokenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "mr_enclave",
                |m: &Request_GetLaunchTokenRequest| { &m.mr_enclave },
                |m: &mut Request_GetLaunchTokenRequest| { &mut m.mr_enclave },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "mr_signer",
                |m: &Request_GetLaunchTokenRequest| { &m.mr_signer },
                |m: &mut Request_GetLaunchTokenRequest| { &mut m.mr_signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "se_attributes",
                |m: &Request_GetLaunchTokenRequest| { &m.se_attributes },
                |m: &mut Request_GetLaunchTokenRequest| { &mut m.se_attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetLaunchTokenRequest| { &m.timeout },
                |m: &mut Request_GetLaunchTokenRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetLaunchTokenRequest>(
                "Request.GetLaunchTokenRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetLaunchTokenRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetLaunchTokenRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetLaunchTokenRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetLaunchTokenRequest {
    fn clear(&mut self) {
        self.mr_enclave.clear();
        self.mr_signer.clear();
        self.se_attributes.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetLaunchTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetLaunchTokenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_ReportAttestationErrorRequest {
    // message fields
    platform_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    attestation_error_code: ::std::option::Option<u32>,
    update_info_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_ReportAttestationErrorRequest {
    fn default() -> &'a Request_ReportAttestationErrorRequest {
        <Request_ReportAttestationErrorRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_ReportAttestationErrorRequest {
    pub fn new() -> Request_ReportAttestationErrorRequest {
        ::std::default::Default::default()
    }

    // required bytes platform_info = 1;


    pub fn get_platform_info(&self) -> &[u8] {
        match self.platform_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_info(&mut self) {
        self.platform_info.clear();
    }

    pub fn has_platform_info(&self) -> bool {
        self.platform_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_info.is_none() {
            self.platform_info.set_default();
        }
        self.platform_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 attestation_error_code = 2;


    pub fn get_attestation_error_code(&self) -> u32 {
        self.attestation_error_code.unwrap_or(0)
    }
    pub fn clear_attestation_error_code(&mut self) {
        self.attestation_error_code = ::std::option::Option::None;
    }

    pub fn has_attestation_error_code(&self) -> bool {
        self.attestation_error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attestation_error_code(&mut self, v: u32) {
        self.attestation_error_code = ::std::option::Option::Some(v);
    }

    // required uint32 update_info_size = 3;


    pub fn get_update_info_size(&self) -> u32 {
        self.update_info_size.unwrap_or(0)
    }
    pub fn clear_update_info_size(&mut self) {
        self.update_info_size = ::std::option::Option::None;
    }

    pub fn has_update_info_size(&self) -> bool {
        self.update_info_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_info_size(&mut self, v: u32) {
        self.update_info_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_ReportAttestationErrorRequest {
    fn is_initialized(&self) -> bool {
        if self.platform_info.is_none() {
            return false;
        }
        if self.attestation_error_code.is_none() {
            return false;
        }
        if self.update_info_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attestation_error_code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_info_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.platform_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.attestation_error_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_info_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.platform_info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.attestation_error_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.update_info_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_ReportAttestationErrorRequest {
        Request_ReportAttestationErrorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "platform_info",
                |m: &Request_ReportAttestationErrorRequest| { &m.platform_info },
                |m: &mut Request_ReportAttestationErrorRequest| { &mut m.platform_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attestation_error_code",
                |m: &Request_ReportAttestationErrorRequest| { &m.attestation_error_code },
                |m: &mut Request_ReportAttestationErrorRequest| { &mut m.attestation_error_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "update_info_size",
                |m: &Request_ReportAttestationErrorRequest| { &m.update_info_size },
                |m: &mut Request_ReportAttestationErrorRequest| { &mut m.update_info_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_ReportAttestationErrorRequest| { &m.timeout },
                |m: &mut Request_ReportAttestationErrorRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_ReportAttestationErrorRequest>(
                "Request.ReportAttestationErrorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_ReportAttestationErrorRequest {
        static instance: ::protobuf::rt::LazyV2<Request_ReportAttestationErrorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_ReportAttestationErrorRequest::new)
    }
}

impl ::protobuf::Clear for Request_ReportAttestationErrorRequest {
    fn clear(&mut self) {
        self.platform_info.clear();
        self.attestation_error_code = ::std::option::Option::None;
        self.update_info_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_ReportAttestationErrorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_ReportAttestationErrorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_CheckUpdateStatusRequest {
    // message fields
    platform_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    update_info_size: ::std::option::Option<u32>,
    config: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_CheckUpdateStatusRequest {
    fn default() -> &'a Request_CheckUpdateStatusRequest {
        <Request_CheckUpdateStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_CheckUpdateStatusRequest {
    pub fn new() -> Request_CheckUpdateStatusRequest {
        ::std::default::Default::default()
    }

    // optional bytes platform_info = 1;


    pub fn get_platform_info(&self) -> &[u8] {
        match self.platform_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_info(&mut self) {
        self.platform_info.clear();
    }

    pub fn has_platform_info(&self) -> bool {
        self.platform_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_info.is_none() {
            self.platform_info.set_default();
        }
        self.platform_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 update_info_size = 2;


    pub fn get_update_info_size(&self) -> u32 {
        self.update_info_size.unwrap_or(0)
    }
    pub fn clear_update_info_size(&mut self) {
        self.update_info_size = ::std::option::Option::None;
    }

    pub fn has_update_info_size(&self) -> bool {
        self.update_info_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_info_size(&mut self, v: u32) {
        self.update_info_size = ::std::option::Option::Some(v);
    }

    // required uint32 config = 3;


    pub fn get_config(&self) -> u32 {
        self.config.unwrap_or(0)
    }
    pub fn clear_config(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: u32) {
        self.config = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_CheckUpdateStatusRequest {
    fn is_initialized(&self) -> bool {
        if self.update_info_size.is_none() {
            return false;
        }
        if self.config.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_info_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.config = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.platform_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.update_info_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.config {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.platform_info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.update_info_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.config {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_CheckUpdateStatusRequest {
        Request_CheckUpdateStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "platform_info",
                |m: &Request_CheckUpdateStatusRequest| { &m.platform_info },
                |m: &mut Request_CheckUpdateStatusRequest| { &mut m.platform_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "update_info_size",
                |m: &Request_CheckUpdateStatusRequest| { &m.update_info_size },
                |m: &mut Request_CheckUpdateStatusRequest| { &mut m.update_info_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "config",
                |m: &Request_CheckUpdateStatusRequest| { &m.config },
                |m: &mut Request_CheckUpdateStatusRequest| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_CheckUpdateStatusRequest| { &m.timeout },
                |m: &mut Request_CheckUpdateStatusRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_CheckUpdateStatusRequest>(
                "Request.CheckUpdateStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_CheckUpdateStatusRequest {
        static instance: ::protobuf::rt::LazyV2<Request_CheckUpdateStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_CheckUpdateStatusRequest::new)
    }
}

impl ::protobuf::Clear for Request_CheckUpdateStatusRequest {
    fn clear(&mut self) {
        self.platform_info.clear();
        self.update_info_size = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_CheckUpdateStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_CheckUpdateStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetWhiteListSizeRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetWhiteListSizeRequest {
    fn default() -> &'a Request_GetWhiteListSizeRequest {
        <Request_GetWhiteListSizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetWhiteListSizeRequest {
    pub fn new() -> Request_GetWhiteListSizeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetWhiteListSizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetWhiteListSizeRequest {
        Request_GetWhiteListSizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetWhiteListSizeRequest| { &m.timeout },
                |m: &mut Request_GetWhiteListSizeRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetWhiteListSizeRequest>(
                "Request.GetWhiteListSizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetWhiteListSizeRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetWhiteListSizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetWhiteListSizeRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetWhiteListSizeRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetWhiteListSizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetWhiteListSizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetWhiteListRequest {
    // message fields
    white_list_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetWhiteListRequest {
    fn default() -> &'a Request_GetWhiteListRequest {
        <Request_GetWhiteListRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetWhiteListRequest {
    pub fn new() -> Request_GetWhiteListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 white_list_size = 1;


    pub fn get_white_list_size(&self) -> u32 {
        self.white_list_size.unwrap_or(0)
    }
    pub fn clear_white_list_size(&mut self) {
        self.white_list_size = ::std::option::Option::None;
    }

    pub fn has_white_list_size(&self) -> bool {
        self.white_list_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list_size(&mut self, v: u32) {
        self.white_list_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetWhiteListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.white_list_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.white_list_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.white_list_size {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetWhiteListRequest {
        Request_GetWhiteListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "white_list_size",
                |m: &Request_GetWhiteListRequest| { &m.white_list_size },
                |m: &mut Request_GetWhiteListRequest| { &mut m.white_list_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetWhiteListRequest| { &m.timeout },
                |m: &mut Request_GetWhiteListRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetWhiteListRequest>(
                "Request.GetWhiteListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetWhiteListRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetWhiteListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetWhiteListRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetWhiteListRequest {
    fn clear(&mut self) {
        self.white_list_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetWhiteListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetWhiteListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_SGXGetExtendedEpidGroupIdRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXGetExtendedEpidGroupIdRequest {
    fn default() -> &'a Request_SGXGetExtendedEpidGroupIdRequest {
        <Request_SGXGetExtendedEpidGroupIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXGetExtendedEpidGroupIdRequest {
    pub fn new() -> Request_SGXGetExtendedEpidGroupIdRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXGetExtendedEpidGroupIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXGetExtendedEpidGroupIdRequest {
        Request_SGXGetExtendedEpidGroupIdRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_SGXGetExtendedEpidGroupIdRequest| { &m.timeout },
                |m: &mut Request_SGXGetExtendedEpidGroupIdRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_SGXGetExtendedEpidGroupIdRequest>(
                "Request.SGXGetExtendedEpidGroupIdRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_SGXGetExtendedEpidGroupIdRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXGetExtendedEpidGroupIdRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXGetExtendedEpidGroupIdRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXGetExtendedEpidGroupIdRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_SGXGetExtendedEpidGroupIdRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXGetExtendedEpidGroupIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_SGXSwitchExtendedEpidGroupRequest {
    // message fields
    x_group_id: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXSwitchExtendedEpidGroupRequest {
    fn default() -> &'a Request_SGXSwitchExtendedEpidGroupRequest {
        <Request_SGXSwitchExtendedEpidGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXSwitchExtendedEpidGroupRequest {
    pub fn new() -> Request_SGXSwitchExtendedEpidGroupRequest {
        ::std::default::Default::default()
    }

    // optional uint32 x_group_id = 1;


    pub fn get_x_group_id(&self) -> u32 {
        self.x_group_id.unwrap_or(0)
    }
    pub fn clear_x_group_id(&mut self) {
        self.x_group_id = ::std::option::Option::None;
    }

    pub fn has_x_group_id(&self) -> bool {
        self.x_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_group_id(&mut self, v: u32) {
        self.x_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXSwitchExtendedEpidGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x_group_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXSwitchExtendedEpidGroupRequest {
        Request_SGXSwitchExtendedEpidGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "x_group_id",
                |m: &Request_SGXSwitchExtendedEpidGroupRequest| { &m.x_group_id },
                |m: &mut Request_SGXSwitchExtendedEpidGroupRequest| { &mut m.x_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_SGXSwitchExtendedEpidGroupRequest| { &m.timeout },
                |m: &mut Request_SGXSwitchExtendedEpidGroupRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_SGXSwitchExtendedEpidGroupRequest>(
                "Request.SGXSwitchExtendedEpidGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_SGXSwitchExtendedEpidGroupRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXSwitchExtendedEpidGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXSwitchExtendedEpidGroupRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXSwitchExtendedEpidGroupRequest {
    fn clear(&mut self) {
        self.x_group_id = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_SGXSwitchExtendedEpidGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXSwitchExtendedEpidGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_SGXRegisterRequest {
    // message fields
    buf: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data_type: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXRegisterRequest {
    fn default() -> &'a Request_SGXRegisterRequest {
        <Request_SGXRegisterRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXRegisterRequest {
    pub fn new() -> Request_SGXRegisterRequest {
        ::std::default::Default::default()
    }

    // required bytes buf = 1;


    pub fn get_buf(&self) -> &[u8] {
        match self.buf.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_buf(&mut self) {
        self.buf.clear();
    }

    pub fn has_buf(&self) -> bool {
        self.buf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf(&mut self, v: ::std::vec::Vec<u8>) {
        self.buf = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buf.is_none() {
            self.buf.set_default();
        }
        self.buf.as_mut().unwrap()
    }

    // Take field
    pub fn take_buf(&mut self) -> ::std::vec::Vec<u8> {
        self.buf.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 data_type = 2;


    pub fn get_data_type(&self) -> u32 {
        self.data_type.unwrap_or(0)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: u32) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXRegisterRequest {
    fn is_initialized(&self) -> bool {
        if self.buf.is_none() {
            return false;
        }
        if self.data_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buf)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.buf.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.buf.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.data_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXRegisterRequest {
        Request_SGXRegisterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "buf",
                |m: &Request_SGXRegisterRequest| { &m.buf },
                |m: &mut Request_SGXRegisterRequest| { &mut m.buf },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_type",
                |m: &Request_SGXRegisterRequest| { &m.data_type },
                |m: &mut Request_SGXRegisterRequest| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_SGXRegisterRequest| { &m.timeout },
                |m: &mut Request_SGXRegisterRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_SGXRegisterRequest>(
                "Request.SGXRegisterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_SGXRegisterRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXRegisterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXRegisterRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXRegisterRequest {
    fn clear(&mut self) {
        self.buf.clear();
        self.data_type = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_SGXRegisterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXRegisterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_InitQuoteExRequest {
    // message fields
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    b_pub_key_id: ::std::option::Option<bool>,
    buf_size: ::std::option::Option<u64>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_InitQuoteExRequest {
    fn default() -> &'a Request_InitQuoteExRequest {
        <Request_InitQuoteExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_InitQuoteExRequest {
    pub fn new() -> Request_InitQuoteExRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id = 1;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool b_pub_key_id = 3;


    pub fn get_b_pub_key_id(&self) -> bool {
        self.b_pub_key_id.unwrap_or(false)
    }
    pub fn clear_b_pub_key_id(&mut self) {
        self.b_pub_key_id = ::std::option::Option::None;
    }

    pub fn has_b_pub_key_id(&self) -> bool {
        self.b_pub_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b_pub_key_id(&mut self, v: bool) {
        self.b_pub_key_id = ::std::option::Option::Some(v);
    }

    // optional uint64 buf_size = 4;


    pub fn get_buf_size(&self) -> u64 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u64) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_InitQuoteExRequest {
    fn is_initialized(&self) -> bool {
        if self.b_pub_key_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.b_pub_key_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.b_pub_key_id {
            my_size += 2;
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.b_pub_key_id {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_InitQuoteExRequest {
        Request_InitQuoteExRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "att_key_id",
                |m: &Request_InitQuoteExRequest| { &m.att_key_id },
                |m: &mut Request_InitQuoteExRequest| { &mut m.att_key_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "b_pub_key_id",
                |m: &Request_InitQuoteExRequest| { &m.b_pub_key_id },
                |m: &mut Request_InitQuoteExRequest| { &mut m.b_pub_key_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "buf_size",
                |m: &Request_InitQuoteExRequest| { &m.buf_size },
                |m: &mut Request_InitQuoteExRequest| { &mut m.buf_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_InitQuoteExRequest| { &m.timeout },
                |m: &mut Request_InitQuoteExRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_InitQuoteExRequest>(
                "Request.InitQuoteExRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_InitQuoteExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_InitQuoteExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_InitQuoteExRequest::new)
    }
}

impl ::protobuf::Clear for Request_InitQuoteExRequest {
    fn clear(&mut self) {
        self.att_key_id.clear();
        self.b_pub_key_id = ::std::option::Option::None;
        self.buf_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_InitQuoteExRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_InitQuoteExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_SelectAttKeyIDRequest {
    // message fields
    att_key_id_list: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SelectAttKeyIDRequest {
    fn default() -> &'a Request_SelectAttKeyIDRequest {
        <Request_SelectAttKeyIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SelectAttKeyIDRequest {
    pub fn new() -> Request_SelectAttKeyIDRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id_list = 1;


    pub fn get_att_key_id_list(&self) -> &[u8] {
        match self.att_key_id_list.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id_list(&mut self) {
        self.att_key_id_list.clear();
    }

    pub fn has_att_key_id_list(&self) -> bool {
        self.att_key_id_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id_list.is_none() {
            self.att_key_id_list.set_default();
        }
        self.att_key_id_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id_list(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id_list.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 2;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SelectAttKeyIDRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id_list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id_list.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id_list.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SelectAttKeyIDRequest {
        Request_SelectAttKeyIDRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "att_key_id_list",
                |m: &Request_SelectAttKeyIDRequest| { &m.att_key_id_list },
                |m: &mut Request_SelectAttKeyIDRequest| { &mut m.att_key_id_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_SelectAttKeyIDRequest| { &m.timeout },
                |m: &mut Request_SelectAttKeyIDRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_SelectAttKeyIDRequest>(
                "Request.SelectAttKeyIDRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_SelectAttKeyIDRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SelectAttKeyIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SelectAttKeyIDRequest::new)
    }
}

impl ::protobuf::Clear for Request_SelectAttKeyIDRequest {
    fn clear(&mut self) {
        self.att_key_id_list.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_SelectAttKeyIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SelectAttKeyIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetQuoteSizeExRequest {
    // message fields
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteSizeExRequest {
    fn default() -> &'a Request_GetQuoteSizeExRequest {
        <Request_GetQuoteSizeExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteSizeExRequest {
    pub fn new() -> Request_GetQuoteSizeExRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id = 1;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteSizeExRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteSizeExRequest {
        Request_GetQuoteSizeExRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "att_key_id",
                |m: &Request_GetQuoteSizeExRequest| { &m.att_key_id },
                |m: &mut Request_GetQuoteSizeExRequest| { &mut m.att_key_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetQuoteSizeExRequest| { &m.timeout },
                |m: &mut Request_GetQuoteSizeExRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetQuoteSizeExRequest>(
                "Request.GetQuoteSizeExRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetQuoteSizeExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteSizeExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteSizeExRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteSizeExRequest {
    fn clear(&mut self) {
        self.att_key_id.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetQuoteSizeExRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteSizeExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetQuoteExRequest {
    // message fields
    report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buf_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteExRequest {
    fn default() -> &'a Request_GetQuoteExRequest {
        <Request_GetQuoteExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteExRequest {
    pub fn new() -> Request_GetQuoteExRequest {
        ::std::default::Default::default()
    }

    // required bytes report = 1;


    pub fn get_report(&self) -> &[u8] {
        match self.report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_report(&mut self) {
        self.report.clear();
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.report.is_none() {
            self.report.set_default();
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::vec::Vec<u8> {
        self.report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes att_key_id = 2;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report_info = 3;


    pub fn get_qe_report_info(&self) -> &[u8] {
        match self.qe_report_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report_info(&mut self) {
        self.qe_report_info.clear();
    }

    pub fn has_qe_report_info(&self) -> bool {
        self.qe_report_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report_info.is_none() {
            self.qe_report_info.set_default();
        }
        self.qe_report_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report_info(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 buf_size = 4;


    pub fn get_buf_size(&self) -> u32 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u32) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteExRequest {
    fn is_initialized(&self) -> bool {
        if self.report.is_none() {
            return false;
        }
        if self.buf_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.report)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report_info)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.report.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteExRequest {
        Request_GetQuoteExRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "report",
                |m: &Request_GetQuoteExRequest| { &m.report },
                |m: &mut Request_GetQuoteExRequest| { &mut m.report },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "att_key_id",
                |m: &Request_GetQuoteExRequest| { &m.att_key_id },
                |m: &mut Request_GetQuoteExRequest| { &mut m.att_key_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "qe_report_info",
                |m: &Request_GetQuoteExRequest| { &m.qe_report_info },
                |m: &mut Request_GetQuoteExRequest| { &mut m.qe_report_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buf_size",
                |m: &Request_GetQuoteExRequest| { &m.buf_size },
                |m: &mut Request_GetQuoteExRequest| { &mut m.buf_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetQuoteExRequest| { &m.timeout },
                |m: &mut Request_GetQuoteExRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetQuoteExRequest>(
                "Request.GetQuoteExRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetQuoteExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteExRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteExRequest {
    fn clear(&mut self) {
        self.report.clear();
        self.att_key_id.clear();
        self.qe_report_info.clear();
        self.buf_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetQuoteExRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetSupportedAttKeyIDNumRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetSupportedAttKeyIDNumRequest {
    fn default() -> &'a Request_GetSupportedAttKeyIDNumRequest {
        <Request_GetSupportedAttKeyIDNumRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetSupportedAttKeyIDNumRequest {
    pub fn new() -> Request_GetSupportedAttKeyIDNumRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetSupportedAttKeyIDNumRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetSupportedAttKeyIDNumRequest {
        Request_GetSupportedAttKeyIDNumRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetSupportedAttKeyIDNumRequest| { &m.timeout },
                |m: &mut Request_GetSupportedAttKeyIDNumRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetSupportedAttKeyIDNumRequest>(
                "Request.GetSupportedAttKeyIDNumRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetSupportedAttKeyIDNumRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetSupportedAttKeyIDNumRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetSupportedAttKeyIDNumRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetSupportedAttKeyIDNumRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetSupportedAttKeyIDNumRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetSupportedAttKeyIDNumRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request_GetSupportedAttKeyIDsRequest {
    // message fields
    buf_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetSupportedAttKeyIDsRequest {
    fn default() -> &'a Request_GetSupportedAttKeyIDsRequest {
        <Request_GetSupportedAttKeyIDsRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetSupportedAttKeyIDsRequest {
    pub fn new() -> Request_GetSupportedAttKeyIDsRequest {
        ::std::default::Default::default()
    }

    // required uint32 buf_size = 1;


    pub fn get_buf_size(&self) -> u32 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u32) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetSupportedAttKeyIDsRequest {
    fn is_initialized(&self) -> bool {
        if self.buf_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.buf_size {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetSupportedAttKeyIDsRequest {
        Request_GetSupportedAttKeyIDsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "buf_size",
                |m: &Request_GetSupportedAttKeyIDsRequest| { &m.buf_size },
                |m: &mut Request_GetSupportedAttKeyIDsRequest| { &mut m.buf_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout",
                |m: &Request_GetSupportedAttKeyIDsRequest| { &m.timeout },
                |m: &mut Request_GetSupportedAttKeyIDsRequest| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Request_GetSupportedAttKeyIDsRequest>(
                "Request.GetSupportedAttKeyIDsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Request_GetSupportedAttKeyIDsRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetSupportedAttKeyIDsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetSupportedAttKeyIDsRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetSupportedAttKeyIDsRequest {
    fn clear(&mut self) {
        self.buf_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request_GetSupportedAttKeyIDsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetSupportedAttKeyIDsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub initQuoteRes: ::protobuf::SingularPtrField<Response_InitQuoteResponse>,
    pub getQuoteRes: ::protobuf::SingularPtrField<Response_GetQuoteResponse>,
    pub getLicTokenRes: ::protobuf::SingularPtrField<Response_GetLaunchTokenResponse>,
    pub reportErrRes: ::protobuf::SingularPtrField<Response_ReportAttestationErrorResponse>,
    pub getWhiteListSizeRes: ::protobuf::SingularPtrField<Response_GetWhiteListSizeResponse>,
    pub getWhiteListRes: ::protobuf::SingularPtrField<Response_GetWhiteListResponse>,
    pub sgxGetExtendedEpidGroupIdRes: ::protobuf::SingularPtrField<Response_SGXGetExtendedEpidGroupIdResponse>,
    pub sgxSwitchExtendedEpidGroupRes: ::protobuf::SingularPtrField<Response_SGXSwitchExtendedEpidGroupResponse>,
    pub sgxRegisterRes: ::protobuf::SingularPtrField<Response_SGXRegisterResponse>,
    pub initQuoteExRes: ::protobuf::SingularPtrField<Response_InitQuoteExResponse>,
    pub getQuoteSizeExRes: ::protobuf::SingularPtrField<Response_GetQuoteSizeExResponse>,
    pub getQuoteExRes: ::protobuf::SingularPtrField<Response_GetQuoteExResponse>,
    pub checkUpdateStatusRes: ::protobuf::SingularPtrField<Response_CheckUpdateStatusResponse>,
    pub selectAttKeyIDRes: ::protobuf::SingularPtrField<Response_SelectAttKeyIDResponse>,
    pub unsupportedRequestResponse: ::protobuf::SingularPtrField<Response_UnsupportedRequestResponse>,
    pub getSupportedAttKeyIDNumRes: ::protobuf::SingularPtrField<Response_GetSupportedAttKeyIDNumResponse>,
    pub getSupportedAttKeyIDsRes: ::protobuf::SingularPtrField<Response_GetSupportedAttKeyIDsResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;


    pub fn get_initQuoteRes(&self) -> &Response_InitQuoteResponse {
        self.initQuoteRes.as_ref().unwrap_or_else(|| <Response_InitQuoteResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteRes(&mut self) {
        self.initQuoteRes.clear();
    }

    pub fn has_initQuoteRes(&self) -> bool {
        self.initQuoteRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteRes(&mut self, v: Response_InitQuoteResponse) {
        self.initQuoteRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteRes(&mut self) -> &mut Response_InitQuoteResponse {
        if self.initQuoteRes.is_none() {
            self.initQuoteRes.set_default();
        }
        self.initQuoteRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteRes(&mut self) -> Response_InitQuoteResponse {
        self.initQuoteRes.take().unwrap_or_else(|| Response_InitQuoteResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;


    pub fn get_getQuoteRes(&self) -> &Response_GetQuoteResponse {
        self.getQuoteRes.as_ref().unwrap_or_else(|| <Response_GetQuoteResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteRes(&mut self) {
        self.getQuoteRes.clear();
    }

    pub fn has_getQuoteRes(&self) -> bool {
        self.getQuoteRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteRes(&mut self, v: Response_GetQuoteResponse) {
        self.getQuoteRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteRes(&mut self) -> &mut Response_GetQuoteResponse {
        if self.getQuoteRes.is_none() {
            self.getQuoteRes.set_default();
        }
        self.getQuoteRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteRes(&mut self) -> Response_GetQuoteResponse {
        self.getQuoteRes.take().unwrap_or_else(|| Response_GetQuoteResponse::new())
    }

    // optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;


    pub fn get_getLicTokenRes(&self) -> &Response_GetLaunchTokenResponse {
        self.getLicTokenRes.as_ref().unwrap_or_else(|| <Response_GetLaunchTokenResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLicTokenRes(&mut self) {
        self.getLicTokenRes.clear();
    }

    pub fn has_getLicTokenRes(&self) -> bool {
        self.getLicTokenRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLicTokenRes(&mut self, v: Response_GetLaunchTokenResponse) {
        self.getLicTokenRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLicTokenRes(&mut self) -> &mut Response_GetLaunchTokenResponse {
        if self.getLicTokenRes.is_none() {
            self.getLicTokenRes.set_default();
        }
        self.getLicTokenRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLicTokenRes(&mut self) -> Response_GetLaunchTokenResponse {
        self.getLicTokenRes.take().unwrap_or_else(|| Response_GetLaunchTokenResponse::new())
    }

    // optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;


    pub fn get_reportErrRes(&self) -> &Response_ReportAttestationErrorResponse {
        self.reportErrRes.as_ref().unwrap_or_else(|| <Response_ReportAttestationErrorResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reportErrRes(&mut self) {
        self.reportErrRes.clear();
    }

    pub fn has_reportErrRes(&self) -> bool {
        self.reportErrRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportErrRes(&mut self, v: Response_ReportAttestationErrorResponse) {
        self.reportErrRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportErrRes(&mut self) -> &mut Response_ReportAttestationErrorResponse {
        if self.reportErrRes.is_none() {
            self.reportErrRes.set_default();
        }
        self.reportErrRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportErrRes(&mut self) -> Response_ReportAttestationErrorResponse {
        self.reportErrRes.take().unwrap_or_else(|| Response_ReportAttestationErrorResponse::new())
    }

    // optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;


    pub fn get_getWhiteListSizeRes(&self) -> &Response_GetWhiteListSizeResponse {
        self.getWhiteListSizeRes.as_ref().unwrap_or_else(|| <Response_GetWhiteListSizeResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListSizeRes(&mut self) {
        self.getWhiteListSizeRes.clear();
    }

    pub fn has_getWhiteListSizeRes(&self) -> bool {
        self.getWhiteListSizeRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListSizeRes(&mut self, v: Response_GetWhiteListSizeResponse) {
        self.getWhiteListSizeRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListSizeRes(&mut self) -> &mut Response_GetWhiteListSizeResponse {
        if self.getWhiteListSizeRes.is_none() {
            self.getWhiteListSizeRes.set_default();
        }
        self.getWhiteListSizeRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListSizeRes(&mut self) -> Response_GetWhiteListSizeResponse {
        self.getWhiteListSizeRes.take().unwrap_or_else(|| Response_GetWhiteListSizeResponse::new())
    }

    // optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;


    pub fn get_getWhiteListRes(&self) -> &Response_GetWhiteListResponse {
        self.getWhiteListRes.as_ref().unwrap_or_else(|| <Response_GetWhiteListResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListRes(&mut self) {
        self.getWhiteListRes.clear();
    }

    pub fn has_getWhiteListRes(&self) -> bool {
        self.getWhiteListRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListRes(&mut self, v: Response_GetWhiteListResponse) {
        self.getWhiteListRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListRes(&mut self) -> &mut Response_GetWhiteListResponse {
        if self.getWhiteListRes.is_none() {
            self.getWhiteListRes.set_default();
        }
        self.getWhiteListRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListRes(&mut self) -> Response_GetWhiteListResponse {
        self.getWhiteListRes.take().unwrap_or_else(|| Response_GetWhiteListResponse::new())
    }

    // optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;


    pub fn get_sgxGetExtendedEpidGroupIdRes(&self) -> &Response_SGXGetExtendedEpidGroupIdResponse {
        self.sgxGetExtendedEpidGroupIdRes.as_ref().unwrap_or_else(|| <Response_SGXGetExtendedEpidGroupIdResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxGetExtendedEpidGroupIdRes(&mut self) {
        self.sgxGetExtendedEpidGroupIdRes.clear();
    }

    pub fn has_sgxGetExtendedEpidGroupIdRes(&self) -> bool {
        self.sgxGetExtendedEpidGroupIdRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxGetExtendedEpidGroupIdRes(&mut self, v: Response_SGXGetExtendedEpidGroupIdResponse) {
        self.sgxGetExtendedEpidGroupIdRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxGetExtendedEpidGroupIdRes(&mut self) -> &mut Response_SGXGetExtendedEpidGroupIdResponse {
        if self.sgxGetExtendedEpidGroupIdRes.is_none() {
            self.sgxGetExtendedEpidGroupIdRes.set_default();
        }
        self.sgxGetExtendedEpidGroupIdRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxGetExtendedEpidGroupIdRes(&mut self) -> Response_SGXGetExtendedEpidGroupIdResponse {
        self.sgxGetExtendedEpidGroupIdRes.take().unwrap_or_else(|| Response_SGXGetExtendedEpidGroupIdResponse::new())
    }

    // optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;


    pub fn get_sgxSwitchExtendedEpidGroupRes(&self) -> &Response_SGXSwitchExtendedEpidGroupResponse {
        self.sgxSwitchExtendedEpidGroupRes.as_ref().unwrap_or_else(|| <Response_SGXSwitchExtendedEpidGroupResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxSwitchExtendedEpidGroupRes(&mut self) {
        self.sgxSwitchExtendedEpidGroupRes.clear();
    }

    pub fn has_sgxSwitchExtendedEpidGroupRes(&self) -> bool {
        self.sgxSwitchExtendedEpidGroupRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxSwitchExtendedEpidGroupRes(&mut self, v: Response_SGXSwitchExtendedEpidGroupResponse) {
        self.sgxSwitchExtendedEpidGroupRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxSwitchExtendedEpidGroupRes(&mut self) -> &mut Response_SGXSwitchExtendedEpidGroupResponse {
        if self.sgxSwitchExtendedEpidGroupRes.is_none() {
            self.sgxSwitchExtendedEpidGroupRes.set_default();
        }
        self.sgxSwitchExtendedEpidGroupRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxSwitchExtendedEpidGroupRes(&mut self) -> Response_SGXSwitchExtendedEpidGroupResponse {
        self.sgxSwitchExtendedEpidGroupRes.take().unwrap_or_else(|| Response_SGXSwitchExtendedEpidGroupResponse::new())
    }

    // optional .aesm.message.Response.SGXRegisterResponse sgxRegisterRes = 14;


    pub fn get_sgxRegisterRes(&self) -> &Response_SGXRegisterResponse {
        self.sgxRegisterRes.as_ref().unwrap_or_else(|| <Response_SGXRegisterResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxRegisterRes(&mut self) {
        self.sgxRegisterRes.clear();
    }

    pub fn has_sgxRegisterRes(&self) -> bool {
        self.sgxRegisterRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxRegisterRes(&mut self, v: Response_SGXRegisterResponse) {
        self.sgxRegisterRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxRegisterRes(&mut self) -> &mut Response_SGXRegisterResponse {
        if self.sgxRegisterRes.is_none() {
            self.sgxRegisterRes.set_default();
        }
        self.sgxRegisterRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxRegisterRes(&mut self) -> Response_SGXRegisterResponse {
        self.sgxRegisterRes.take().unwrap_or_else(|| Response_SGXRegisterResponse::new())
    }

    // optional .aesm.message.Response.InitQuoteExResponse initQuoteExRes = 15;


    pub fn get_initQuoteExRes(&self) -> &Response_InitQuoteExResponse {
        self.initQuoteExRes.as_ref().unwrap_or_else(|| <Response_InitQuoteExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteExRes(&mut self) {
        self.initQuoteExRes.clear();
    }

    pub fn has_initQuoteExRes(&self) -> bool {
        self.initQuoteExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteExRes(&mut self, v: Response_InitQuoteExResponse) {
        self.initQuoteExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteExRes(&mut self) -> &mut Response_InitQuoteExResponse {
        if self.initQuoteExRes.is_none() {
            self.initQuoteExRes.set_default();
        }
        self.initQuoteExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteExRes(&mut self) -> Response_InitQuoteExResponse {
        self.initQuoteExRes.take().unwrap_or_else(|| Response_InitQuoteExResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteSizeExResponse getQuoteSizeExRes = 16;


    pub fn get_getQuoteSizeExRes(&self) -> &Response_GetQuoteSizeExResponse {
        self.getQuoteSizeExRes.as_ref().unwrap_or_else(|| <Response_GetQuoteSizeExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteSizeExRes(&mut self) {
        self.getQuoteSizeExRes.clear();
    }

    pub fn has_getQuoteSizeExRes(&self) -> bool {
        self.getQuoteSizeExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteSizeExRes(&mut self, v: Response_GetQuoteSizeExResponse) {
        self.getQuoteSizeExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteSizeExRes(&mut self) -> &mut Response_GetQuoteSizeExResponse {
        if self.getQuoteSizeExRes.is_none() {
            self.getQuoteSizeExRes.set_default();
        }
        self.getQuoteSizeExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteSizeExRes(&mut self) -> Response_GetQuoteSizeExResponse {
        self.getQuoteSizeExRes.take().unwrap_or_else(|| Response_GetQuoteSizeExResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteExResponse getQuoteExRes = 17;


    pub fn get_getQuoteExRes(&self) -> &Response_GetQuoteExResponse {
        self.getQuoteExRes.as_ref().unwrap_or_else(|| <Response_GetQuoteExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteExRes(&mut self) {
        self.getQuoteExRes.clear();
    }

    pub fn has_getQuoteExRes(&self) -> bool {
        self.getQuoteExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteExRes(&mut self, v: Response_GetQuoteExResponse) {
        self.getQuoteExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteExRes(&mut self) -> &mut Response_GetQuoteExResponse {
        if self.getQuoteExRes.is_none() {
            self.getQuoteExRes.set_default();
        }
        self.getQuoteExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteExRes(&mut self) -> Response_GetQuoteExResponse {
        self.getQuoteExRes.take().unwrap_or_else(|| Response_GetQuoteExResponse::new())
    }

    // optional .aesm.message.Response.CheckUpdateStatusResponse checkUpdateStatusRes = 18;


    pub fn get_checkUpdateStatusRes(&self) -> &Response_CheckUpdateStatusResponse {
        self.checkUpdateStatusRes.as_ref().unwrap_or_else(|| <Response_CheckUpdateStatusResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checkUpdateStatusRes(&mut self) {
        self.checkUpdateStatusRes.clear();
    }

    pub fn has_checkUpdateStatusRes(&self) -> bool {
        self.checkUpdateStatusRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkUpdateStatusRes(&mut self, v: Response_CheckUpdateStatusResponse) {
        self.checkUpdateStatusRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkUpdateStatusRes(&mut self) -> &mut Response_CheckUpdateStatusResponse {
        if self.checkUpdateStatusRes.is_none() {
            self.checkUpdateStatusRes.set_default();
        }
        self.checkUpdateStatusRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_checkUpdateStatusRes(&mut self) -> Response_CheckUpdateStatusResponse {
        self.checkUpdateStatusRes.take().unwrap_or_else(|| Response_CheckUpdateStatusResponse::new())
    }

    // optional .aesm.message.Response.SelectAttKeyIDResponse selectAttKeyIDRes = 19;


    pub fn get_selectAttKeyIDRes(&self) -> &Response_SelectAttKeyIDResponse {
        self.selectAttKeyIDRes.as_ref().unwrap_or_else(|| <Response_SelectAttKeyIDResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selectAttKeyIDRes(&mut self) {
        self.selectAttKeyIDRes.clear();
    }

    pub fn has_selectAttKeyIDRes(&self) -> bool {
        self.selectAttKeyIDRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectAttKeyIDRes(&mut self, v: Response_SelectAttKeyIDResponse) {
        self.selectAttKeyIDRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectAttKeyIDRes(&mut self) -> &mut Response_SelectAttKeyIDResponse {
        if self.selectAttKeyIDRes.is_none() {
            self.selectAttKeyIDRes.set_default();
        }
        self.selectAttKeyIDRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectAttKeyIDRes(&mut self) -> Response_SelectAttKeyIDResponse {
        self.selectAttKeyIDRes.take().unwrap_or_else(|| Response_SelectAttKeyIDResponse::new())
    }

    // optional .aesm.message.Response.UnsupportedRequestResponse unsupportedRequestResponse = 20;


    pub fn get_unsupportedRequestResponse(&self) -> &Response_UnsupportedRequestResponse {
        self.unsupportedRequestResponse.as_ref().unwrap_or_else(|| <Response_UnsupportedRequestResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unsupportedRequestResponse(&mut self) {
        self.unsupportedRequestResponse.clear();
    }

    pub fn has_unsupportedRequestResponse(&self) -> bool {
        self.unsupportedRequestResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsupportedRequestResponse(&mut self, v: Response_UnsupportedRequestResponse) {
        self.unsupportedRequestResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsupportedRequestResponse(&mut self) -> &mut Response_UnsupportedRequestResponse {
        if self.unsupportedRequestResponse.is_none() {
            self.unsupportedRequestResponse.set_default();
        }
        self.unsupportedRequestResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsupportedRequestResponse(&mut self) -> Response_UnsupportedRequestResponse {
        self.unsupportedRequestResponse.take().unwrap_or_else(|| Response_UnsupportedRequestResponse::new())
    }

    // optional .aesm.message.Response.GetSupportedAttKeyIDNumResponse getSupportedAttKeyIDNumRes = 21;


    pub fn get_getSupportedAttKeyIDNumRes(&self) -> &Response_GetSupportedAttKeyIDNumResponse {
        self.getSupportedAttKeyIDNumRes.as_ref().unwrap_or_else(|| <Response_GetSupportedAttKeyIDNumResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSupportedAttKeyIDNumRes(&mut self) {
        self.getSupportedAttKeyIDNumRes.clear();
    }

    pub fn has_getSupportedAttKeyIDNumRes(&self) -> bool {
        self.getSupportedAttKeyIDNumRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSupportedAttKeyIDNumRes(&mut self, v: Response_GetSupportedAttKeyIDNumResponse) {
        self.getSupportedAttKeyIDNumRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSupportedAttKeyIDNumRes(&mut self) -> &mut Response_GetSupportedAttKeyIDNumResponse {
        if self.getSupportedAttKeyIDNumRes.is_none() {
            self.getSupportedAttKeyIDNumRes.set_default();
        }
        self.getSupportedAttKeyIDNumRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSupportedAttKeyIDNumRes(&mut self) -> Response_GetSupportedAttKeyIDNumResponse {
        self.getSupportedAttKeyIDNumRes.take().unwrap_or_else(|| Response_GetSupportedAttKeyIDNumResponse::new())
    }

    // optional .aesm.message.Response.GetSupportedAttKeyIDsResponse getSupportedAttKeyIDsRes = 22;


    pub fn get_getSupportedAttKeyIDsRes(&self) -> &Response_GetSupportedAttKeyIDsResponse {
        self.getSupportedAttKeyIDsRes.as_ref().unwrap_or_else(|| <Response_GetSupportedAttKeyIDsResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getSupportedAttKeyIDsRes(&mut self) {
        self.getSupportedAttKeyIDsRes.clear();
    }

    pub fn has_getSupportedAttKeyIDsRes(&self) -> bool {
        self.getSupportedAttKeyIDsRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSupportedAttKeyIDsRes(&mut self, v: Response_GetSupportedAttKeyIDsResponse) {
        self.getSupportedAttKeyIDsRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSupportedAttKeyIDsRes(&mut self) -> &mut Response_GetSupportedAttKeyIDsResponse {
        if self.getSupportedAttKeyIDsRes.is_none() {
            self.getSupportedAttKeyIDsRes.set_default();
        }
        self.getSupportedAttKeyIDsRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSupportedAttKeyIDsRes(&mut self) -> Response_GetSupportedAttKeyIDsResponse {
        self.getSupportedAttKeyIDsRes.take().unwrap_or_else(|| Response_GetSupportedAttKeyIDsResponse::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        for v in &self.initQuoteRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLicTokenRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reportErrRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListSizeRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxGetExtendedEpidGroupIdRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxSwitchExtendedEpidGroupRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxRegisterRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initQuoteExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteSizeExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkUpdateStatusRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selectAttKeyIDRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsupportedRequestResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSupportedAttKeyIDNumRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSupportedAttKeyIDsRes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteRes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteRes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLicTokenRes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reportErrRes)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListSizeRes)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListRes)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxGetExtendedEpidGroupIdRes)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxSwitchExtendedEpidGroupRes)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxRegisterRes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteExRes)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteSizeExRes)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteExRes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkUpdateStatusRes)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selectAttKeyIDRes)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsupportedRequestResponse)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSupportedAttKeyIDNumRes)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSupportedAttKeyIDsRes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initQuoteRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLicTokenRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reportErrRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListSizeRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxRegisterRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initQuoteExRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteSizeExRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteExRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkUpdateStatusRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selectAttKeyIDRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsupportedRequestResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDNumRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDsRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initQuoteRes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteRes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLicTokenRes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reportErrRes.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListSizeRes.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListRes.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdRes.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupRes.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxRegisterRes.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initQuoteExRes.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteSizeExRes.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteExRes.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkUpdateStatusRes.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selectAttKeyIDRes.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsupportedRequestResponse.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDNumRes.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSupportedAttKeyIDsRes.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_InitQuoteResponse>>(
                "initQuoteRes",
                |m: &Response| { &m.initQuoteRes },
                |m: &mut Response| { &mut m.initQuoteRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetQuoteResponse>>(
                "getQuoteRes",
                |m: &Response| { &m.getQuoteRes },
                |m: &mut Response| { &mut m.getQuoteRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetLaunchTokenResponse>>(
                "getLicTokenRes",
                |m: &Response| { &m.getLicTokenRes },
                |m: &mut Response| { &mut m.getLicTokenRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_ReportAttestationErrorResponse>>(
                "reportErrRes",
                |m: &Response| { &m.reportErrRes },
                |m: &mut Response| { &mut m.reportErrRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetWhiteListSizeResponse>>(
                "getWhiteListSizeRes",
                |m: &Response| { &m.getWhiteListSizeRes },
                |m: &mut Response| { &mut m.getWhiteListSizeRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetWhiteListResponse>>(
                "getWhiteListRes",
                |m: &Response| { &m.getWhiteListRes },
                |m: &mut Response| { &mut m.getWhiteListRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_SGXGetExtendedEpidGroupIdResponse>>(
                "sgxGetExtendedEpidGroupIdRes",
                |m: &Response| { &m.sgxGetExtendedEpidGroupIdRes },
                |m: &mut Response| { &mut m.sgxGetExtendedEpidGroupIdRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_SGXSwitchExtendedEpidGroupResponse>>(
                "sgxSwitchExtendedEpidGroupRes",
                |m: &Response| { &m.sgxSwitchExtendedEpidGroupRes },
                |m: &mut Response| { &mut m.sgxSwitchExtendedEpidGroupRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_SGXRegisterResponse>>(
                "sgxRegisterRes",
                |m: &Response| { &m.sgxRegisterRes },
                |m: &mut Response| { &mut m.sgxRegisterRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_InitQuoteExResponse>>(
                "initQuoteExRes",
                |m: &Response| { &m.initQuoteExRes },
                |m: &mut Response| { &mut m.initQuoteExRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetQuoteSizeExResponse>>(
                "getQuoteSizeExRes",
                |m: &Response| { &m.getQuoteSizeExRes },
                |m: &mut Response| { &mut m.getQuoteSizeExRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetQuoteExResponse>>(
                "getQuoteExRes",
                |m: &Response| { &m.getQuoteExRes },
                |m: &mut Response| { &mut m.getQuoteExRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_CheckUpdateStatusResponse>>(
                "checkUpdateStatusRes",
                |m: &Response| { &m.checkUpdateStatusRes },
                |m: &mut Response| { &mut m.checkUpdateStatusRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_SelectAttKeyIDResponse>>(
                "selectAttKeyIDRes",
                |m: &Response| { &m.selectAttKeyIDRes },
                |m: &mut Response| { &mut m.selectAttKeyIDRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_UnsupportedRequestResponse>>(
                "unsupportedRequestResponse",
                |m: &Response| { &m.unsupportedRequestResponse },
                |m: &mut Response| { &mut m.unsupportedRequestResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetSupportedAttKeyIDNumResponse>>(
                "getSupportedAttKeyIDNumRes",
                |m: &Response| { &m.getSupportedAttKeyIDNumRes },
                |m: &mut Response| { &mut m.getSupportedAttKeyIDNumRes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response_GetSupportedAttKeyIDsResponse>>(
                "getSupportedAttKeyIDsRes",
                |m: &Response| { &m.getSupportedAttKeyIDsRes },
                |m: &mut Response| { &mut m.getSupportedAttKeyIDsRes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                "Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response {
        static instance: ::protobuf::rt::LazyV2<Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response::new)
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.initQuoteRes.clear();
        self.getQuoteRes.clear();
        self.getLicTokenRes.clear();
        self.reportErrRes.clear();
        self.getWhiteListSizeRes.clear();
        self.getWhiteListRes.clear();
        self.sgxGetExtendedEpidGroupIdRes.clear();
        self.sgxSwitchExtendedEpidGroupRes.clear();
        self.sgxRegisterRes.clear();
        self.initQuoteExRes.clear();
        self.getQuoteSizeExRes.clear();
        self.getQuoteExRes.clear();
        self.checkUpdateStatusRes.clear();
        self.selectAttKeyIDRes.clear();
        self.unsupportedRequestResponse.clear();
        self.getSupportedAttKeyIDNumRes.clear();
        self.getSupportedAttKeyIDsRes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_InitQuoteResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    targetInfo: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_InitQuoteResponse {
    fn default() -> &'a Response_InitQuoteResponse {
        <Response_InitQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_InitQuoteResponse {
    pub fn new() -> Response_InitQuoteResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes targetInfo = 2;


    pub fn get_targetInfo(&self) -> &[u8] {
        match self.targetInfo.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_targetInfo(&mut self) {
        self.targetInfo.clear();
    }

    pub fn has_targetInfo(&self) -> bool {
        self.targetInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetInfo(&mut self, v: ::std::vec::Vec<u8>) {
        self.targetInfo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetInfo(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.targetInfo.is_none() {
            self.targetInfo.set_default();
        }
        self.targetInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetInfo(&mut self) -> ::std::vec::Vec<u8> {
        self.targetInfo.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes gid = 3;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_InitQuoteResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.targetInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.targetInfo.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.targetInfo.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_InitQuoteResponse {
        Response_InitQuoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_InitQuoteResponse| { &m.errorCode },
                |m: &mut Response_InitQuoteResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "targetInfo",
                |m: &Response_InitQuoteResponse| { &m.targetInfo },
                |m: &mut Response_InitQuoteResponse| { &mut m.targetInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "gid",
                |m: &Response_InitQuoteResponse| { &m.gid },
                |m: &mut Response_InitQuoteResponse| { &mut m.gid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_InitQuoteResponse>(
                "Response.InitQuoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_InitQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<Response_InitQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_InitQuoteResponse::new)
    }
}

impl ::protobuf::Clear for Response_InitQuoteResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.targetInfo.clear();
        self.gid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_InitQuoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_InitQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetQuoteResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteResponse {
    fn default() -> &'a Response_GetQuoteResponse {
        <Response_GetQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteResponse {
    pub fn new() -> Response_GetQuoteResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes quote = 2;


    pub fn get_quote(&self) -> &[u8] {
        match self.quote.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::vec::Vec<u8>) {
        self.quote = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::vec::Vec<u8> {
        self.quote.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report = 3;


    pub fn get_qe_report(&self) -> &[u8] {
        match self.qe_report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report(&mut self) {
        self.qe_report.clear();
    }

    pub fn has_qe_report(&self) -> bool {
        self.qe_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report.is_none() {
            self.qe_report.set_default();
        }
        self.qe_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetQuoteResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.quote)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteResponse {
        Response_GetQuoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetQuoteResponse| { &m.errorCode },
                |m: &mut Response_GetQuoteResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "quote",
                |m: &Response_GetQuoteResponse| { &m.quote },
                |m: &mut Response_GetQuoteResponse| { &mut m.quote },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "qe_report",
                |m: &Response_GetQuoteResponse| { &m.qe_report },
                |m: &mut Response_GetQuoteResponse| { &mut m.qe_report },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetQuoteResponse>(
                "Response.GetQuoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote.clear();
        self.qe_report.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetQuoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetLaunchTokenResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetLaunchTokenResponse {
    fn default() -> &'a Response_GetLaunchTokenResponse {
        <Response_GetLaunchTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetLaunchTokenResponse {
    pub fn new() -> Response_GetLaunchTokenResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetLaunchTokenResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetLaunchTokenResponse {
        Response_GetLaunchTokenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetLaunchTokenResponse| { &m.errorCode },
                |m: &mut Response_GetLaunchTokenResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &Response_GetLaunchTokenResponse| { &m.token },
                |m: &mut Response_GetLaunchTokenResponse| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetLaunchTokenResponse>(
                "Response.GetLaunchTokenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetLaunchTokenResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetLaunchTokenResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetLaunchTokenResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetLaunchTokenResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetLaunchTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetLaunchTokenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_ReportAttestationErrorResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    platform_update_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_ReportAttestationErrorResponse {
    fn default() -> &'a Response_ReportAttestationErrorResponse {
        <Response_ReportAttestationErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_ReportAttestationErrorResponse {
    pub fn new() -> Response_ReportAttestationErrorResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes platform_update_info = 2;


    pub fn get_platform_update_info(&self) -> &[u8] {
        match self.platform_update_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_update_info(&mut self) {
        self.platform_update_info.clear();
    }

    pub fn has_platform_update_info(&self) -> bool {
        self.platform_update_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_update_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_update_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_update_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_update_info.is_none() {
            self.platform_update_info.set_default();
        }
        self.platform_update_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_update_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_update_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_ReportAttestationErrorResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_update_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_ReportAttestationErrorResponse {
        Response_ReportAttestationErrorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_ReportAttestationErrorResponse| { &m.errorCode },
                |m: &mut Response_ReportAttestationErrorResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "platform_update_info",
                |m: &Response_ReportAttestationErrorResponse| { &m.platform_update_info },
                |m: &mut Response_ReportAttestationErrorResponse| { &mut m.platform_update_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_ReportAttestationErrorResponse>(
                "Response.ReportAttestationErrorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_ReportAttestationErrorResponse {
        static instance: ::protobuf::rt::LazyV2<Response_ReportAttestationErrorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_ReportAttestationErrorResponse::new)
    }
}

impl ::protobuf::Clear for Response_ReportAttestationErrorResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.platform_update_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_ReportAttestationErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_ReportAttestationErrorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_CheckUpdateStatusResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    platform_update_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    status: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_CheckUpdateStatusResponse {
    fn default() -> &'a Response_CheckUpdateStatusResponse {
        <Response_CheckUpdateStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_CheckUpdateStatusResponse {
    pub fn new() -> Response_CheckUpdateStatusResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes platform_update_info = 2;


    pub fn get_platform_update_info(&self) -> &[u8] {
        match self.platform_update_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_update_info(&mut self) {
        self.platform_update_info.clear();
    }

    pub fn has_platform_update_info(&self) -> bool {
        self.platform_update_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_update_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_update_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_update_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_update_info.is_none() {
            self.platform_update_info.set_default();
        }
        self.platform_update_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_update_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_update_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 status = 3;


    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_CheckUpdateStatusResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_update_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_CheckUpdateStatusResponse {
        Response_CheckUpdateStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_CheckUpdateStatusResponse| { &m.errorCode },
                |m: &mut Response_CheckUpdateStatusResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "platform_update_info",
                |m: &Response_CheckUpdateStatusResponse| { &m.platform_update_info },
                |m: &mut Response_CheckUpdateStatusResponse| { &mut m.platform_update_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status",
                |m: &Response_CheckUpdateStatusResponse| { &m.status },
                |m: &mut Response_CheckUpdateStatusResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_CheckUpdateStatusResponse>(
                "Response.CheckUpdateStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_CheckUpdateStatusResponse {
        static instance: ::protobuf::rt::LazyV2<Response_CheckUpdateStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_CheckUpdateStatusResponse::new)
    }
}

impl ::protobuf::Clear for Response_CheckUpdateStatusResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.platform_update_info.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_CheckUpdateStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_CheckUpdateStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetWhiteListSizeResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    white_list_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetWhiteListSizeResponse {
    fn default() -> &'a Response_GetWhiteListSizeResponse {
        <Response_GetWhiteListSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetWhiteListSizeResponse {
    pub fn new() -> Response_GetWhiteListSizeResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 white_list_size = 2;


    pub fn get_white_list_size(&self) -> u32 {
        self.white_list_size.unwrap_or(0)
    }
    pub fn clear_white_list_size(&mut self) {
        self.white_list_size = ::std::option::Option::None;
    }

    pub fn has_white_list_size(&self) -> bool {
        self.white_list_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list_size(&mut self, v: u32) {
        self.white_list_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_GetWhiteListSizeResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.white_list_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.white_list_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.white_list_size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetWhiteListSizeResponse {
        Response_GetWhiteListSizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetWhiteListSizeResponse| { &m.errorCode },
                |m: &mut Response_GetWhiteListSizeResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "white_list_size",
                |m: &Response_GetWhiteListSizeResponse| { &m.white_list_size },
                |m: &mut Response_GetWhiteListSizeResponse| { &mut m.white_list_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetWhiteListSizeResponse>(
                "Response.GetWhiteListSizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetWhiteListSizeResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetWhiteListSizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetWhiteListSizeResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetWhiteListSizeResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.white_list_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetWhiteListSizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetWhiteListSizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetWhiteListResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    white_list: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetWhiteListResponse {
    fn default() -> &'a Response_GetWhiteListResponse {
        <Response_GetWhiteListResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetWhiteListResponse {
    pub fn new() -> Response_GetWhiteListResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes white_list = 2;


    pub fn get_white_list(&self) -> &[u8] {
        match self.white_list.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_white_list(&mut self) {
        self.white_list.clear();
    }

    pub fn has_white_list(&self) -> bool {
        self.white_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.white_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_white_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.white_list.is_none() {
            self.white_list.set_default();
        }
        self.white_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_white_list(&mut self) -> ::std::vec::Vec<u8> {
        self.white_list.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetWhiteListResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.white_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.white_list.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.white_list.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetWhiteListResponse {
        Response_GetWhiteListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetWhiteListResponse| { &m.errorCode },
                |m: &mut Response_GetWhiteListResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "white_list",
                |m: &Response_GetWhiteListResponse| { &m.white_list },
                |m: &mut Response_GetWhiteListResponse| { &mut m.white_list },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetWhiteListResponse>(
                "Response.GetWhiteListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetWhiteListResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetWhiteListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetWhiteListResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetWhiteListResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.white_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetWhiteListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetWhiteListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_SGXGetExtendedEpidGroupIdResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    x_group_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXGetExtendedEpidGroupIdResponse {
    fn default() -> &'a Response_SGXGetExtendedEpidGroupIdResponse {
        <Response_SGXGetExtendedEpidGroupIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXGetExtendedEpidGroupIdResponse {
    pub fn new() -> Response_SGXGetExtendedEpidGroupIdResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 x_group_id = 2;


    pub fn get_x_group_id(&self) -> u32 {
        self.x_group_id.unwrap_or(0)
    }
    pub fn clear_x_group_id(&mut self) {
        self.x_group_id = ::std::option::Option::None;
    }

    pub fn has_x_group_id(&self) -> bool {
        self.x_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_group_id(&mut self, v: u32) {
        self.x_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXGetExtendedEpidGroupIdResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_group_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXGetExtendedEpidGroupIdResponse {
        Response_SGXGetExtendedEpidGroupIdResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_SGXGetExtendedEpidGroupIdResponse| { &m.errorCode },
                |m: &mut Response_SGXGetExtendedEpidGroupIdResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "x_group_id",
                |m: &Response_SGXGetExtendedEpidGroupIdResponse| { &m.x_group_id },
                |m: &mut Response_SGXGetExtendedEpidGroupIdResponse| { &mut m.x_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_SGXGetExtendedEpidGroupIdResponse>(
                "Response.SGXGetExtendedEpidGroupIdResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_SGXGetExtendedEpidGroupIdResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXGetExtendedEpidGroupIdResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXGetExtendedEpidGroupIdResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXGetExtendedEpidGroupIdResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.x_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_SGXGetExtendedEpidGroupIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXGetExtendedEpidGroupIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_SGXSwitchExtendedEpidGroupResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXSwitchExtendedEpidGroupResponse {
    fn default() -> &'a Response_SGXSwitchExtendedEpidGroupResponse {
        <Response_SGXSwitchExtendedEpidGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXSwitchExtendedEpidGroupResponse {
    pub fn new() -> Response_SGXSwitchExtendedEpidGroupResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXSwitchExtendedEpidGroupResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXSwitchExtendedEpidGroupResponse {
        Response_SGXSwitchExtendedEpidGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_SGXSwitchExtendedEpidGroupResponse| { &m.errorCode },
                |m: &mut Response_SGXSwitchExtendedEpidGroupResponse| { &mut m.errorCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_SGXSwitchExtendedEpidGroupResponse>(
                "Response.SGXSwitchExtendedEpidGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_SGXSwitchExtendedEpidGroupResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXSwitchExtendedEpidGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXSwitchExtendedEpidGroupResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXSwitchExtendedEpidGroupResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_SGXSwitchExtendedEpidGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXSwitchExtendedEpidGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_SGXRegisterResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXRegisterResponse {
    fn default() -> &'a Response_SGXRegisterResponse {
        <Response_SGXRegisterResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXRegisterResponse {
    pub fn new() -> Response_SGXRegisterResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXRegisterResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXRegisterResponse {
        Response_SGXRegisterResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_SGXRegisterResponse| { &m.errorCode },
                |m: &mut Response_SGXRegisterResponse| { &mut m.errorCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_SGXRegisterResponse>(
                "Response.SGXRegisterResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_SGXRegisterResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXRegisterResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXRegisterResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXRegisterResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_SGXRegisterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXRegisterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_SelectAttKeyIDResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    selected_att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SelectAttKeyIDResponse {
    fn default() -> &'a Response_SelectAttKeyIDResponse {
        <Response_SelectAttKeyIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SelectAttKeyIDResponse {
    pub fn new() -> Response_SelectAttKeyIDResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes selected_att_key_id = 2;


    pub fn get_selected_att_key_id(&self) -> &[u8] {
        match self.selected_att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_selected_att_key_id(&mut self) {
        self.selected_att_key_id.clear();
    }

    pub fn has_selected_att_key_id(&self) -> bool {
        self.selected_att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selected_att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.selected_att_key_id.is_none() {
            self.selected_att_key_id.set_default();
        }
        self.selected_att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.selected_att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_SelectAttKeyIDResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.selected_att_key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.selected_att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.selected_att_key_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SelectAttKeyIDResponse {
        Response_SelectAttKeyIDResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_SelectAttKeyIDResponse| { &m.errorCode },
                |m: &mut Response_SelectAttKeyIDResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "selected_att_key_id",
                |m: &Response_SelectAttKeyIDResponse| { &m.selected_att_key_id },
                |m: &mut Response_SelectAttKeyIDResponse| { &mut m.selected_att_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_SelectAttKeyIDResponse>(
                "Response.SelectAttKeyIDResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_SelectAttKeyIDResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SelectAttKeyIDResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SelectAttKeyIDResponse::new)
    }
}

impl ::protobuf::Clear for Response_SelectAttKeyIDResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.selected_att_key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_SelectAttKeyIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SelectAttKeyIDResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_InitQuoteExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    target_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub_key_id_size: ::std::option::Option<u64>,
    pub_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_InitQuoteExResponse {
    fn default() -> &'a Response_InitQuoteExResponse {
        <Response_InitQuoteExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_InitQuoteExResponse {
    pub fn new() -> Response_InitQuoteExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes target_info = 2;


    pub fn get_target_info(&self) -> &[u8] {
        match self.target_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_target_info(&mut self) {
        self.target_info.clear();
    }

    pub fn has_target_info(&self) -> bool {
        self.target_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.target_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.target_info.is_none() {
            self.target_info.set_default();
        }
        self.target_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_info(&mut self) -> ::std::vec::Vec<u8> {
        self.target_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 pub_key_id_size = 3;


    pub fn get_pub_key_id_size(&self) -> u64 {
        self.pub_key_id_size.unwrap_or(0)
    }
    pub fn clear_pub_key_id_size(&mut self) {
        self.pub_key_id_size = ::std::option::Option::None;
    }

    pub fn has_pub_key_id_size(&self) -> bool {
        self.pub_key_id_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_id_size(&mut self, v: u64) {
        self.pub_key_id_size = ::std::option::Option::Some(v);
    }

    // optional bytes pub_key_id = 4;


    pub fn get_pub_key_id(&self) -> &[u8] {
        match self.pub_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pub_key_id(&mut self) {
        self.pub_key_id.clear();
    }

    pub fn has_pub_key_id(&self) -> bool {
        self.pub_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pub_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pub_key_id.is_none() {
            self.pub_key_id.set_default();
        }
        self.pub_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.pub_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_InitQuoteExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.target_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pub_key_id_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pub_key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.pub_key_id_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pub_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.target_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.pub_key_id_size {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.pub_key_id.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_InitQuoteExResponse {
        Response_InitQuoteExResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_InitQuoteExResponse| { &m.errorCode },
                |m: &mut Response_InitQuoteExResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "target_info",
                |m: &Response_InitQuoteExResponse| { &m.target_info },
                |m: &mut Response_InitQuoteExResponse| { &mut m.target_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pub_key_id_size",
                |m: &Response_InitQuoteExResponse| { &m.pub_key_id_size },
                |m: &mut Response_InitQuoteExResponse| { &mut m.pub_key_id_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pub_key_id",
                |m: &Response_InitQuoteExResponse| { &m.pub_key_id },
                |m: &mut Response_InitQuoteExResponse| { &mut m.pub_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_InitQuoteExResponse>(
                "Response.InitQuoteExResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_InitQuoteExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_InitQuoteExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_InitQuoteExResponse::new)
    }
}

impl ::protobuf::Clear for Response_InitQuoteExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.target_info.clear();
        self.pub_key_id_size = ::std::option::Option::None;
        self.pub_key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_InitQuoteExResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_InitQuoteExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetQuoteSizeExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteSizeExResponse {
    fn default() -> &'a Response_GetQuoteSizeExResponse {
        <Response_GetQuoteSizeExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteSizeExResponse {
    pub fn new() -> Response_GetQuoteSizeExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 quote_size = 2;


    pub fn get_quote_size(&self) -> u32 {
        self.quote_size.unwrap_or(0)
    }
    pub fn clear_quote_size(&mut self) {
        self.quote_size = ::std::option::Option::None;
    }

    pub fn has_quote_size(&self) -> bool {
        self.quote_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_size(&mut self, v: u32) {
        self.quote_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_GetQuoteSizeExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quote_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quote_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quote_size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteSizeExResponse {
        Response_GetQuoteSizeExResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetQuoteSizeExResponse| { &m.errorCode },
                |m: &mut Response_GetQuoteSizeExResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quote_size",
                |m: &Response_GetQuoteSizeExResponse| { &m.quote_size },
                |m: &mut Response_GetQuoteSizeExResponse| { &mut m.quote_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetQuoteSizeExResponse>(
                "Response.GetQuoteSizeExResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetQuoteSizeExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteSizeExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteSizeExResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteSizeExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetQuoteSizeExResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteSizeExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetQuoteExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteExResponse {
    fn default() -> &'a Response_GetQuoteExResponse {
        <Response_GetQuoteExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteExResponse {
    pub fn new() -> Response_GetQuoteExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes quote = 2;


    pub fn get_quote(&self) -> &[u8] {
        match self.quote.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::vec::Vec<u8>) {
        self.quote = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::vec::Vec<u8> {
        self.quote.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report_info = 3;


    pub fn get_qe_report_info(&self) -> &[u8] {
        match self.qe_report_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report_info(&mut self) {
        self.qe_report_info.clear();
    }

    pub fn has_qe_report_info(&self) -> bool {
        self.qe_report_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report_info.is_none() {
            self.qe_report_info.set_default();
        }
        self.qe_report_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report_info(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetQuoteExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.quote)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteExResponse {
        Response_GetQuoteExResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetQuoteExResponse| { &m.errorCode },
                |m: &mut Response_GetQuoteExResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "quote",
                |m: &Response_GetQuoteExResponse| { &m.quote },
                |m: &mut Response_GetQuoteExResponse| { &mut m.quote },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "qe_report_info",
                |m: &Response_GetQuoteExResponse| { &m.qe_report_info },
                |m: &mut Response_GetQuoteExResponse| { &mut m.qe_report_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetQuoteExResponse>(
                "Response.GetQuoteExResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetQuoteExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteExResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote.clear();
        self.qe_report_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetQuoteExResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_UnsupportedRequestResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_UnsupportedRequestResponse {
    fn default() -> &'a Response_UnsupportedRequestResponse {
        <Response_UnsupportedRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_UnsupportedRequestResponse {
    pub fn new() -> Response_UnsupportedRequestResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_UnsupportedRequestResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_UnsupportedRequestResponse {
        Response_UnsupportedRequestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_UnsupportedRequestResponse| { &m.errorCode },
                |m: &mut Response_UnsupportedRequestResponse| { &mut m.errorCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_UnsupportedRequestResponse>(
                "Response.UnsupportedRequestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_UnsupportedRequestResponse {
        static instance: ::protobuf::rt::LazyV2<Response_UnsupportedRequestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_UnsupportedRequestResponse::new)
    }
}

impl ::protobuf::Clear for Response_UnsupportedRequestResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_UnsupportedRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_UnsupportedRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetSupportedAttKeyIDNumResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    att_key_id_num: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetSupportedAttKeyIDNumResponse {
    fn default() -> &'a Response_GetSupportedAttKeyIDNumResponse {
        <Response_GetSupportedAttKeyIDNumResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetSupportedAttKeyIDNumResponse {
    pub fn new() -> Response_GetSupportedAttKeyIDNumResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 att_key_id_num = 2;


    pub fn get_att_key_id_num(&self) -> u32 {
        self.att_key_id_num.unwrap_or(0)
    }
    pub fn clear_att_key_id_num(&mut self) {
        self.att_key_id_num = ::std::option::Option::None;
    }

    pub fn has_att_key_id_num(&self) -> bool {
        self.att_key_id_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id_num(&mut self, v: u32) {
        self.att_key_id_num = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_GetSupportedAttKeyIDNumResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.att_key_id_num = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.att_key_id_num {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.att_key_id_num {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetSupportedAttKeyIDNumResponse {
        Response_GetSupportedAttKeyIDNumResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetSupportedAttKeyIDNumResponse| { &m.errorCode },
                |m: &mut Response_GetSupportedAttKeyIDNumResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "att_key_id_num",
                |m: &Response_GetSupportedAttKeyIDNumResponse| { &m.att_key_id_num },
                |m: &mut Response_GetSupportedAttKeyIDNumResponse| { &mut m.att_key_id_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetSupportedAttKeyIDNumResponse>(
                "Response.GetSupportedAttKeyIDNumResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetSupportedAttKeyIDNumResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetSupportedAttKeyIDNumResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetSupportedAttKeyIDNumResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetSupportedAttKeyIDNumResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.att_key_id_num = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetSupportedAttKeyIDNumResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetSupportedAttKeyIDNumResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response_GetSupportedAttKeyIDsResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    att_key_ids: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetSupportedAttKeyIDsResponse {
    fn default() -> &'a Response_GetSupportedAttKeyIDsResponse {
        <Response_GetSupportedAttKeyIDsResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetSupportedAttKeyIDsResponse {
    pub fn new() -> Response_GetSupportedAttKeyIDsResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes att_key_ids = 2;


    pub fn get_att_key_ids(&self) -> &[u8] {
        match self.att_key_ids.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_ids(&mut self) {
        self.att_key_ids.clear();
    }

    pub fn has_att_key_ids(&self) -> bool {
        self.att_key_ids.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_ids(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_ids = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_ids(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_ids.is_none() {
            self.att_key_ids.set_default();
        }
        self.att_key_ids.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_ids(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_ids.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetSupportedAttKeyIDsResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.att_key_ids.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.att_key_ids.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetSupportedAttKeyIDsResponse {
        Response_GetSupportedAttKeyIDsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "errorCode",
                |m: &Response_GetSupportedAttKeyIDsResponse| { &m.errorCode },
                |m: &mut Response_GetSupportedAttKeyIDsResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "att_key_ids",
                |m: &Response_GetSupportedAttKeyIDsResponse| { &m.att_key_ids },
                |m: &mut Response_GetSupportedAttKeyIDsResponse| { &mut m.att_key_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response_GetSupportedAttKeyIDsResponse>(
                "Response.GetSupportedAttKeyIDsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response_GetSupportedAttKeyIDsResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetSupportedAttKeyIDsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetSupportedAttKeyIDsResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetSupportedAttKeyIDsResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.att_key_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response_GetSupportedAttKeyIDsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetSupportedAttKeyIDsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10aesm-proto.proto\x12\x0caesm.message\"\x84\x1b\n\x07Request\x12L\n\
    \x0cinitQuoteReq\x18\x01\x20\x01(\x0b2&.aesm.message.Request.InitQuoteRe\
    questR\x0cinitQuoteReqB\0\x12I\n\x0bgetQuoteReq\x18\x02\x20\x01(\x0b2%.a\
    esm.message.Request.GetQuoteRequestR\x0bgetQuoteReqB\0\x12U\n\x0egetLicT\
    okenReq\x18\x03\x20\x01(\x0b2+.aesm.message.Request.GetLaunchTokenReques\
    tR\x0egetLicTokenReqB\0\x12Y\n\x0creportErrReq\x18\x04\x20\x01(\x0b23.ae\
    sm.message.Request.ReportAttestationErrorRequestR\x0creportErrReqB\0\x12\
    a\n\x13getWhiteListSizeReq\x18\n\x20\x01(\x0b2-.aesm.message.Request.Get\
    WhiteListSizeRequestR\x13getWhiteListSizeReqB\0\x12U\n\x0fgetWhiteListRe\
    q\x18\x0b\x20\x01(\x0b2).aesm.message.Request.GetWhiteListRequestR\x0fge\
    tWhiteListReqB\0\x12|\n\x1csgxGetExtendedEpidGroupIdReq\x18\x0c\x20\x01(\
    \x0b26.aesm.message.Request.SGXGetExtendedEpidGroupIdRequestR\x1csgxGetE\
    xtendedEpidGroupIdReqB\0\x12\x7f\n\x1dsgxSwitchExtendedEpidGroupReq\x18\
    \r\x20\x01(\x0b27.aesm.message.Request.SGXSwitchExtendedEpidGroupRequest\
    R\x1dsgxSwitchExtendedEpidGroupReqB\0\x12R\n\x0esgxRegisterReq\x18\x0e\
    \x20\x01(\x0b2(.aesm.message.Request.SGXRegisterRequestR\x0esgxRegisterR\
    eqB\0\x12R\n\x0einitQuoteExReq\x18\x0f\x20\x01(\x0b2(.aesm.message.Reque\
    st.InitQuoteExRequestR\x0einitQuoteExReqB\0\x12[\n\x11getQuoteSizeExReq\
    \x18\x10\x20\x01(\x0b2+.aesm.message.Request.GetQuoteSizeExRequestR\x11g\
    etQuoteSizeExReqB\0\x12O\n\rgetQuoteExReq\x18\x11\x20\x01(\x0b2'.aesm.me\
    ssage.Request.GetQuoteExRequestR\rgetQuoteExReqB\0\x12d\n\x14checkUpdate\
    StatusReq\x18\x12\x20\x01(\x0b2..aesm.message.Request.CheckUpdateStatusR\
    equestR\x14checkUpdateStatusReqB\0\x12[\n\x11selectAttKeyIDReq\x18\x13\
    \x20\x01(\x0b2+.aesm.message.Request.SelectAttKeyIDRequestR\x11selectAtt\
    KeyIDReqB\0\x12v\n\x1agetSupportedAttKeyIDNumReq\x18\x15\x20\x01(\x0b24.\
    aesm.message.Request.GetSupportedAttKeyIDNumRequestR\x1agetSupportedAttK\
    eyIDNumReqB\0\x12p\n\x18getSupportedAttKeyIDsReq\x18\x16\x20\x01(\x0b22.\
    aesm.message.Request.GetSupportedAttKeyIDsRequestR\x18getSupportedAttKey\
    IDsReqB\0\x1a0\n\x10InitQuoteRequest\x12\x1a\n\x07timeout\x18\t\x20\x01(\
    \rR\x07timeoutB\0:\0\x1a\xed\x01\n\x0fGetQuoteRequest\x12\x18\n\x06repor\
    t\x18\x01\x20\x02(\x0cR\x06reportB\0\x12\x1f\n\nquote_type\x18\x02\x20\
    \x02(\rR\tquoteTypeB\0\x12\x14\n\x04spid\x18\x03\x20\x02(\x0cR\x04spidB\
    \0\x12\x16\n\x05nonce\x18\x04\x20\x01(\x0cR\x05nonceB\0\x12\x17\n\x06sig\
    _rl\x18\x05\x20\x01(\x0cR\x05sigRlB\0\x12\x1b\n\x08buf_size\x18\x06\x20\
    \x02(\rR\x07bufSizeB\0\x12\x1d\n\tqe_report\x18\x07\x20\x01(\x08R\x08qeR\
    eportB\0\x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1a\x9c\
    \x01\n\x15GetLaunchTokenRequest\x12\x1f\n\nmr_enclave\x18\x01\x20\x02(\
    \x0cR\tmrEnclaveB\0\x12\x1d\n\tmr_signer\x18\x02\x20\x02(\x0cR\x08mrSign\
    erB\0\x12%\n\rse_attributes\x18\x03\x20\x02(\x0cR\x0cseAttributesB\0\x12\
    \x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1a\xc8\x01\n\x1dRe\
    portAttestationErrorRequest\x12%\n\rplatform_info\x18\x01\x20\x02(\x0cR\
    \x0cplatformInfoB\0\x126\n\x16attestation_error_code\x18\x02\x20\x02(\rR\
    \x14attestationErrorCodeB\0\x12*\n\x10update_info_size\x18\x03\x20\x02(\
    \rR\x0eupdateInfoSizeB\0\x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeo\
    utB\0:\0\x1a\xa5\x01\n\x18CheckUpdateStatusRequest\x12%\n\rplatform_info\
    \x18\x01\x20\x01(\x0cR\x0cplatformInfoB\0\x12*\n\x10update_info_size\x18\
    \x02\x20\x02(\rR\x0eupdateInfoSizeB\0\x12\x18\n\x06config\x18\x03\x20\
    \x02(\rR\x06configB\0\x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\
    \0:\0\x1a7\n\x17GetWhiteListSizeRequest\x12\x1a\n\x07timeout\x18\t\x20\
    \x01(\rR\x07timeoutB\0:\0\x1a]\n\x13GetWhiteListRequest\x12(\n\x0fwhite_\
    list_size\x18\x01\x20\x01(\rR\rwhiteListSizeB\0\x12\x1a\n\x07timeout\x18\
    \t\x20\x01(\rR\x07timeoutB\0:\0\x1a@\n\x20SGXGetExtendedEpidGroupIdReque\
    st\x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1aa\n!SGXSwi\
    tchExtendedEpidGroupRequest\x12\x1e\n\nx_group_id\x18\x01\x20\x01(\rR\
    \x08xGroupIdB\0\x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\
    \x1ae\n\x12SGXRegisterRequest\x12\x12\n\x03buf\x18\x01\x20\x02(\x0cR\x03\
    bufB\0\x12\x1d\n\tdata_type\x18\x02\x20\x02(\rR\x08dataTypeB\0\x12\x1a\n\
    \x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1a\x92\x01\n\x12InitQuot\
    eExRequest\x12\x1e\n\natt_key_id\x18\x01\x20\x01(\x0cR\x08attKeyIdB\0\
    \x12!\n\x0cb_pub_key_id\x18\x03\x20\x02(\x08R\tbPubKeyIdB\0\x12\x1b\n\
    \x08buf_size\x18\x04\x20\x01(\x04R\x07bufSizeB\0\x12\x1a\n\x07timeout\
    \x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1a^\n\x15SelectAttKeyIDRequest\x12'\
    \n\x0fatt_key_id_list\x18\x01\x20\x01(\x0cR\x0cattKeyIdListB\0\x12\x1a\n\
    \x07timeout\x18\x02\x20\x01(\rR\x07timeoutB\0:\0\x1aU\n\x15GetQuoteSizeE\
    xRequest\x12\x1e\n\natt_key_id\x18\x01\x20\x01(\x0cR\x08attKeyIdB\0\x12\
    \x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1a\xb0\x01\n\x11Ge\
    tQuoteExRequest\x12\x18\n\x06report\x18\x01\x20\x02(\x0cR\x06reportB\0\
    \x12\x1e\n\natt_key_id\x18\x02\x20\x01(\x0cR\x08attKeyIdB\0\x12&\n\x0eqe\
    _report_info\x18\x03\x20\x01(\x0cR\x0cqeReportInfoB\0\x12\x1b\n\x08buf_s\
    ize\x18\x04\x20\x02(\rR\x07bufSizeB\0\x12\x1a\n\x07timeout\x18\t\x20\x01\
    (\rR\x07timeoutB\0:\0\x1a>\n\x1eGetSupportedAttKeyIDNumRequest\x12\x1a\n\
    \x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0\x1aY\n\x1cGetSupportedAtt\
    KeyIDsRequest\x12\x1b\n\x08buf_size\x18\x01\x20\x02(\rR\x07bufSizeB\0\
    \x12\x1a\n\x07timeout\x18\t\x20\x01(\rR\x07timeoutB\0:\0:\0\"\xb4\x1b\n\
    \x08Response\x12N\n\x0cinitQuoteRes\x18\x01\x20\x01(\x0b2(.aesm.message.\
    Response.InitQuoteResponseR\x0cinitQuoteResB\0\x12K\n\x0bgetQuoteRes\x18\
    \x02\x20\x01(\x0b2'.aesm.message.Response.GetQuoteResponseR\x0bgetQuoteR\
    esB\0\x12W\n\x0egetLicTokenRes\x18\x03\x20\x01(\x0b2-.aesm.message.Respo\
    nse.GetLaunchTokenResponseR\x0egetLicTokenResB\0\x12[\n\x0creportErrRes\
    \x18\x04\x20\x01(\x0b25.aesm.message.Response.ReportAttestationErrorResp\
    onseR\x0creportErrResB\0\x12c\n\x13getWhiteListSizeRes\x18\n\x20\x01(\
    \x0b2/.aesm.message.Response.GetWhiteListSizeResponseR\x13getWhiteListSi\
    zeResB\0\x12W\n\x0fgetWhiteListRes\x18\x0b\x20\x01(\x0b2+.aesm.message.R\
    esponse.GetWhiteListResponseR\x0fgetWhiteListResB\0\x12~\n\x1csgxGetExte\
    ndedEpidGroupIdRes\x18\x0c\x20\x01(\x0b28.aesm.message.Response.SGXGetEx\
    tendedEpidGroupIdResponseR\x1csgxGetExtendedEpidGroupIdResB\0\x12\x81\
    \x01\n\x1dsgxSwitchExtendedEpidGroupRes\x18\r\x20\x01(\x0b29.aesm.messag\
    e.Response.SGXSwitchExtendedEpidGroupResponseR\x1dsgxSwitchExtendedEpidG\
    roupResB\0\x12T\n\x0esgxRegisterRes\x18\x0e\x20\x01(\x0b2*.aesm.message.\
    Response.SGXRegisterResponseR\x0esgxRegisterResB\0\x12T\n\x0einitQuoteEx\
    Res\x18\x0f\x20\x01(\x0b2*.aesm.message.Response.InitQuoteExResponseR\
    \x0einitQuoteExResB\0\x12]\n\x11getQuoteSizeExRes\x18\x10\x20\x01(\x0b2-\
    .aesm.message.Response.GetQuoteSizeExResponseR\x11getQuoteSizeExResB\0\
    \x12Q\n\rgetQuoteExRes\x18\x11\x20\x01(\x0b2).aesm.message.Response.GetQ\
    uoteExResponseR\rgetQuoteExResB\0\x12f\n\x14checkUpdateStatusRes\x18\x12\
    \x20\x01(\x0b20.aesm.message.Response.CheckUpdateStatusResponseR\x14chec\
    kUpdateStatusResB\0\x12]\n\x11selectAttKeyIDRes\x18\x13\x20\x01(\x0b2-.a\
    esm.message.Response.SelectAttKeyIDResponseR\x11selectAttKeyIDResB\0\x12\
    s\n\x1aunsupportedRequestResponse\x18\x14\x20\x01(\x0b21.aesm.message.Re\
    sponse.UnsupportedRequestResponseR\x1aunsupportedRequestResponseB\0\x12x\
    \n\x1agetSupportedAttKeyIDNumRes\x18\x15\x20\x01(\x0b26.aesm.message.Res\
    ponse.GetSupportedAttKeyIDNumResponseR\x1agetSupportedAttKeyIDNumResB\0\
    \x12r\n\x18getSupportedAttKeyIDsRes\x18\x16\x20\x01(\x0b24.aesm.message.\
    Response.GetSupportedAttKeyIDsResponseR\x18getSupportedAttKeyIDsResB\0\
    \x1an\n\x11InitQuoteResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\
    \terrorCodeB\0\x12\x20\n\ntargetInfo\x18\x02\x20\x01(\x0cR\ntargetInfoB\
    \0\x12\x12\n\x03gid\x18\x03\x20\x01(\x0cR\x03gidB\0:\0\x1an\n\x10GetQuot\
    eResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x12\
    \x16\n\x05quote\x18\x02\x20\x01(\x0cR\x05quoteB\0\x12\x1d\n\tqe_report\
    \x18\x03\x20\x01(\x0cR\x08qeReportB\0:\0\x1aU\n\x16GetLaunchTokenRespons\
    e\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x12\x16\n\
    \x05token\x18\x02\x20\x01(\x0cR\x05tokenB\0:\0\x1ay\n\x1eReportAttestati\
    onErrorResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\
    \0\x122\n\x14platform_update_info\x18\x02\x20\x01(\x0cR\x12platformUpdat\
    eInfoB\0:\0\x1a\x8e\x01\n\x19CheckUpdateStatusResponse\x12!\n\terrorCode\
    \x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x122\n\x14platform_update_info\
    \x18\x02\x20\x01(\x0cR\x12platformUpdateInfoB\0\x12\x18\n\x06status\x18\
    \x03\x20\x01(\rR\x06statusB\0:\0\x1ai\n\x18GetWhiteListSizeResponse\x12!\
    \n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x12(\n\x0fwhite_li\
    st_size\x18\x02\x20\x01(\rR\rwhiteListSizeB\0:\0\x1a\\\n\x14GetWhiteList\
    Response\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x12\
    \x1f\n\nwhite_list\x18\x02\x20\x01(\x0cR\twhiteListB\0:\0\x1ah\n!SGXGetE\
    xtendedEpidGroupIdResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\t\
    errorCodeB\0\x12\x1e\n\nx_group_id\x18\x02\x20\x01(\rR\x08xGroupIdB\0:\0\
    \x1aI\n\"SGXSwitchExtendedEpidGroupResponse\x12!\n\terrorCode\x18\x01\
    \x20\x02(\r:\x011R\terrorCodeB\0:\0\x1a:\n\x13SGXRegisterResponse\x12!\n\
    \terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0:\0\x1an\n\x16SelectA\
    ttKeyIDResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\
    \0\x12/\n\x13selected_att_key_id\x18\x02\x20\x01(\x0cR\x10selectedAttKey\
    IdB\0:\0\x1a\xa6\x01\n\x13InitQuoteExResponse\x12!\n\terrorCode\x18\x01\
    \x20\x02(\r:\x011R\terrorCodeB\0\x12!\n\x0btarget_info\x18\x02\x20\x01(\
    \x0cR\ntargetInfoB\0\x12'\n\x0fpub_key_id_size\x18\x03\x20\x01(\x04R\x0c\
    pubKeyIdSizeB\0\x12\x1e\n\npub_key_id\x18\x04\x20\x01(\x0cR\x08pubKeyIdB\
    \0:\0\x1a^\n\x16GetQuoteSizeExResponse\x12!\n\terrorCode\x18\x01\x20\x02\
    (\r:\x011R\terrorCodeB\0\x12\x1f\n\nquote_size\x18\x02\x20\x01(\rR\tquot\
    eSizeB\0:\0\x1ay\n\x12GetQuoteExResponse\x12!\n\terrorCode\x18\x01\x20\
    \x02(\r:\x011R\terrorCodeB\0\x12\x16\n\x05quote\x18\x02\x20\x01(\x0cR\
    \x05quoteB\0\x12&\n\x0eqe_report_info\x18\x03\x20\x01(\x0cR\x0cqeReportI\
    nfoB\0:\0\x1aA\n\x1aUnsupportedRequestResponse\x12!\n\terrorCode\x18\x01\
    \x20\x02(\r:\x011R\terrorCodeB\0:\0\x1am\n\x1fGetSupportedAttKeyIDNumRes\
    ponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\terrorCodeB\0\x12%\n\
    \x0eatt_key_id_num\x18\x02\x20\x01(\rR\x0battKeyIdNumB\0:\0\x1af\n\x1dGe\
    tSupportedAttKeyIDsResponse\x12!\n\terrorCode\x18\x01\x20\x02(\r:\x011R\
    \terrorCodeB\0\x12\x20\n\x0batt_key_ids\x18\x02\x20\x01(\x0cR\tattKeyIds\
    B\0:\0:\0B\0b\x06proto2\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
